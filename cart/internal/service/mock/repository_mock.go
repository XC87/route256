// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mock

//go:generate minimock -i route256.ozon.ru/project/cart/internal/service.Repository -o repository_mock.go -n RepositoryMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"route256.ozon.ru/project/cart/internal/domain"
)

// RepositoryMock implements service.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, userId int64, item domain.Item) (err error)
	inspectFuncAddItem   func(ctx context.Context, userId int64, item domain.Item)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mRepositoryMockAddItem

	funcDeleteItem          func(ctx context.Context, userId int64, skuId int64) (err error)
	inspectFuncDeleteItem   func(ctx context.Context, userId int64, skuId int64)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mRepositoryMockDeleteItem

	funcDeleteItemsByUserId          func(ctx context.Context, userId int64) (err error)
	inspectFuncDeleteItemsByUserId   func(ctx context.Context, userId int64)
	afterDeleteItemsByUserIdCounter  uint64
	beforeDeleteItemsByUserIdCounter uint64
	DeleteItemsByUserIdMock          mRepositoryMockDeleteItemsByUserId

	funcGetItemsByUserId          func(ctx context.Context, userId int64) (i1 domain.ItemsMap, err error)
	inspectFuncGetItemsByUserId   func(ctx context.Context, userId int64)
	afterGetItemsByUserIdCounter  uint64
	beforeGetItemsByUserIdCounter uint64
	GetItemsByUserIdMock          mRepositoryMockGetItemsByUserId
}

// NewRepositoryMock returns a mock for service.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mRepositoryMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*RepositoryMockAddItemParams{}

	m.DeleteItemMock = mRepositoryMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*RepositoryMockDeleteItemParams{}

	m.DeleteItemsByUserIdMock = mRepositoryMockDeleteItemsByUserId{mock: m}
	m.DeleteItemsByUserIdMock.callArgs = []*RepositoryMockDeleteItemsByUserIdParams{}

	m.GetItemsByUserIdMock = mRepositoryMockGetItemsByUserId{mock: m}
	m.GetItemsByUserIdMock.callArgs = []*RepositoryMockGetItemsByUserIdParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockAddItem struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddItemExpectation
	expectations       []*RepositoryMockAddItemExpectation

	callArgs []*RepositoryMockAddItemParams
	mutex    sync.RWMutex
}

// RepositoryMockAddItemExpectation specifies expectation struct of the Repository.AddItem
type RepositoryMockAddItemExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockAddItemParams
	results *RepositoryMockAddItemResults
	Counter uint64
}

// RepositoryMockAddItemParams contains parameters of the Repository.AddItem
type RepositoryMockAddItemParams struct {
	ctx    context.Context
	userId int64
	item   domain.Item
}

// RepositoryMockAddItemResults contains results of the Repository.AddItem
type RepositoryMockAddItemResults struct {
	err error
}

// Expect sets up expected params for Repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) Expect(ctx context.Context, userId int64, item domain.Item) *mRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryMockAddItemExpectation{}
	}

	mmAddItem.defaultExpectation.params = &RepositoryMockAddItemParams{ctx, userId, item}
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) Inspect(f func(ctx context.Context, userId int64, item domain.Item)) *mRepositoryMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by Repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) Return(err error) *RepositoryMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &RepositoryMockAddItemResults{err}
	return mmAddItem.mock
}

// Set uses given function f to mock the Repository.AddItem method
func (mmAddItem *mRepositoryMockAddItem) Set(f func(ctx context.Context, userId int64, item domain.Item) (err error)) *RepositoryMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the Repository.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the Repository.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	return mmAddItem.mock
}

// When sets expectation for the Repository.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mRepositoryMockAddItem) When(ctx context.Context, userId int64, item domain.Item) *RepositoryMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	expectation := &RepositoryMockAddItemExpectation{
		mock:   mmAddItem.mock,
		params: &RepositoryMockAddItemParams{ctx, userId, item},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddItemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddItemResults{err}
	return e.mock
}

// AddItem implements service.Repository
func (mmAddItem *RepositoryMock) AddItem(ctx context.Context, userId int64, item domain.Item) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, userId, item)
	}

	mm_params := RepositoryMockAddItemParams{ctx, userId, item}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_got := RepositoryMockAddItemParams{ctx, userId, item}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("RepositoryMock.AddItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the RepositoryMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, userId, item)
	}
	mmAddItem.t.Fatalf("Unexpected call to RepositoryMock.AddItem. %v %v %v", ctx, userId, item)
	return
}

// AddItemAfterCounter returns a count of finished RepositoryMock.AddItem invocations
func (mmAddItem *RepositoryMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of RepositoryMock.AddItem invocations
func (mmAddItem *RepositoryMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mRepositoryMockAddItem) Calls() []*RepositoryMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*RepositoryMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddItemDone() bool {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && mm_atomic.LoadUint64(&m.afterAddItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddItemCounter) < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.AddItem")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddItem with params: %#v", *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && mm_atomic.LoadUint64(&m.afterAddItemCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.AddItem")
	}
}

type mRepositoryMockDeleteItem struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteItemExpectation
	expectations       []*RepositoryMockDeleteItemExpectation

	callArgs []*RepositoryMockDeleteItemParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteItemExpectation specifies expectation struct of the Repository.DeleteItem
type RepositoryMockDeleteItemExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteItemParams
	results *RepositoryMockDeleteItemResults
	Counter uint64
}

// RepositoryMockDeleteItemParams contains parameters of the Repository.DeleteItem
type RepositoryMockDeleteItemParams struct {
	ctx    context.Context
	userId int64
	skuId  int64
}

// RepositoryMockDeleteItemResults contains results of the Repository.DeleteItem
type RepositoryMockDeleteItemResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) Expect(ctx context.Context, userId int64, skuId int64) *mRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryMockDeleteItemExpectation{}
	}

	mmDeleteItem.defaultExpectation.params = &RepositoryMockDeleteItemParams{ctx, userId, skuId}
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) Inspect(f func(ctx context.Context, userId int64, skuId int64)) *mRepositoryMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by Repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) Return(err error) *RepositoryMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &RepositoryMockDeleteItemResults{err}
	return mmDeleteItem.mock
}

// Set uses given function f to mock the Repository.DeleteItem method
func (mmDeleteItem *mRepositoryMockDeleteItem) Set(f func(ctx context.Context, userId int64, skuId int64) (err error)) *RepositoryMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	return mmDeleteItem.mock
}

// When sets expectation for the Repository.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mRepositoryMockDeleteItem) When(ctx context.Context, userId int64, skuId int64) *RepositoryMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteItemExpectation{
		mock:   mmDeleteItem.mock,
		params: &RepositoryMockDeleteItemParams{ctx, userId, skuId},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteItemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteItemResults{err}
	return e.mock
}

// DeleteItem implements service.Repository
func (mmDeleteItem *RepositoryMock) DeleteItem(ctx context.Context, userId int64, skuId int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, userId, skuId)
	}

	mm_params := RepositoryMockDeleteItemParams{ctx, userId, skuId}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteItemParams{ctx, userId, skuId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("RepositoryMock.DeleteItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the RepositoryMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, userId, skuId)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to RepositoryMock.DeleteItem. %v %v %v", ctx, userId, skuId)
	return
}

// DeleteItemAfterCounter returns a count of finished RepositoryMock.DeleteItem invocations
func (mmDeleteItem *RepositoryMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of RepositoryMock.DeleteItem invocations
func (mmDeleteItem *RepositoryMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mRepositoryMockDeleteItem) Calls() []*RepositoryMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteItemDone() bool {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteItem")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItem with params: %#v", *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteItem")
	}
}

type mRepositoryMockDeleteItemsByUserId struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteItemsByUserIdExpectation
	expectations       []*RepositoryMockDeleteItemsByUserIdExpectation

	callArgs []*RepositoryMockDeleteItemsByUserIdParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteItemsByUserIdExpectation specifies expectation struct of the Repository.DeleteItemsByUserId
type RepositoryMockDeleteItemsByUserIdExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteItemsByUserIdParams
	results *RepositoryMockDeleteItemsByUserIdResults
	Counter uint64
}

// RepositoryMockDeleteItemsByUserIdParams contains parameters of the Repository.DeleteItemsByUserId
type RepositoryMockDeleteItemsByUserIdParams struct {
	ctx    context.Context
	userId int64
}

// RepositoryMockDeleteItemsByUserIdResults contains results of the Repository.DeleteItemsByUserId
type RepositoryMockDeleteItemsByUserIdResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteItemsByUserId
func (mmDeleteItemsByUserId *mRepositoryMockDeleteItemsByUserId) Expect(ctx context.Context, userId int64) *mRepositoryMockDeleteItemsByUserId {
	if mmDeleteItemsByUserId.mock.funcDeleteItemsByUserId != nil {
		mmDeleteItemsByUserId.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserId mock is already set by Set")
	}

	if mmDeleteItemsByUserId.defaultExpectation == nil {
		mmDeleteItemsByUserId.defaultExpectation = &RepositoryMockDeleteItemsByUserIdExpectation{}
	}

	mmDeleteItemsByUserId.defaultExpectation.params = &RepositoryMockDeleteItemsByUserIdParams{ctx, userId}
	for _, e := range mmDeleteItemsByUserId.expectations {
		if minimock.Equal(e.params, mmDeleteItemsByUserId.defaultExpectation.params) {
			mmDeleteItemsByUserId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItemsByUserId.defaultExpectation.params)
		}
	}

	return mmDeleteItemsByUserId
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteItemsByUserId
func (mmDeleteItemsByUserId *mRepositoryMockDeleteItemsByUserId) Inspect(f func(ctx context.Context, userId int64)) *mRepositoryMockDeleteItemsByUserId {
	if mmDeleteItemsByUserId.mock.inspectFuncDeleteItemsByUserId != nil {
		mmDeleteItemsByUserId.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteItemsByUserId")
	}

	mmDeleteItemsByUserId.mock.inspectFuncDeleteItemsByUserId = f

	return mmDeleteItemsByUserId
}

// Return sets up results that will be returned by Repository.DeleteItemsByUserId
func (mmDeleteItemsByUserId *mRepositoryMockDeleteItemsByUserId) Return(err error) *RepositoryMock {
	if mmDeleteItemsByUserId.mock.funcDeleteItemsByUserId != nil {
		mmDeleteItemsByUserId.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserId mock is already set by Set")
	}

	if mmDeleteItemsByUserId.defaultExpectation == nil {
		mmDeleteItemsByUserId.defaultExpectation = &RepositoryMockDeleteItemsByUserIdExpectation{mock: mmDeleteItemsByUserId.mock}
	}
	mmDeleteItemsByUserId.defaultExpectation.results = &RepositoryMockDeleteItemsByUserIdResults{err}
	return mmDeleteItemsByUserId.mock
}

// Set uses given function f to mock the Repository.DeleteItemsByUserId method
func (mmDeleteItemsByUserId *mRepositoryMockDeleteItemsByUserId) Set(f func(ctx context.Context, userId int64) (err error)) *RepositoryMock {
	if mmDeleteItemsByUserId.defaultExpectation != nil {
		mmDeleteItemsByUserId.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteItemsByUserId method")
	}

	if len(mmDeleteItemsByUserId.expectations) > 0 {
		mmDeleteItemsByUserId.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteItemsByUserId method")
	}

	mmDeleteItemsByUserId.mock.funcDeleteItemsByUserId = f
	return mmDeleteItemsByUserId.mock
}

// When sets expectation for the Repository.DeleteItemsByUserId which will trigger the result defined by the following
// Then helper
func (mmDeleteItemsByUserId *mRepositoryMockDeleteItemsByUserId) When(ctx context.Context, userId int64) *RepositoryMockDeleteItemsByUserIdExpectation {
	if mmDeleteItemsByUserId.mock.funcDeleteItemsByUserId != nil {
		mmDeleteItemsByUserId.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserId mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteItemsByUserIdExpectation{
		mock:   mmDeleteItemsByUserId.mock,
		params: &RepositoryMockDeleteItemsByUserIdParams{ctx, userId},
	}
	mmDeleteItemsByUserId.expectations = append(mmDeleteItemsByUserId.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteItemsByUserId return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteItemsByUserIdExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteItemsByUserIdResults{err}
	return e.mock
}

// DeleteItemsByUserId implements service.Repository
func (mmDeleteItemsByUserId *RepositoryMock) DeleteItemsByUserId(ctx context.Context, userId int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteItemsByUserId.beforeDeleteItemsByUserIdCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItemsByUserId.afterDeleteItemsByUserIdCounter, 1)

	if mmDeleteItemsByUserId.inspectFuncDeleteItemsByUserId != nil {
		mmDeleteItemsByUserId.inspectFuncDeleteItemsByUserId(ctx, userId)
	}

	mm_params := RepositoryMockDeleteItemsByUserIdParams{ctx, userId}

	// Record call args
	mmDeleteItemsByUserId.DeleteItemsByUserIdMock.mutex.Lock()
	mmDeleteItemsByUserId.DeleteItemsByUserIdMock.callArgs = append(mmDeleteItemsByUserId.DeleteItemsByUserIdMock.callArgs, &mm_params)
	mmDeleteItemsByUserId.DeleteItemsByUserIdMock.mutex.Unlock()

	for _, e := range mmDeleteItemsByUserId.DeleteItemsByUserIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItemsByUserId.DeleteItemsByUserIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItemsByUserId.DeleteItemsByUserIdMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItemsByUserId.DeleteItemsByUserIdMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteItemsByUserIdParams{ctx, userId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItemsByUserId.t.Errorf("RepositoryMock.DeleteItemsByUserId got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItemsByUserId.DeleteItemsByUserIdMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItemsByUserId.t.Fatal("No results are set for the RepositoryMock.DeleteItemsByUserId")
		}
		return (*mm_results).err
	}
	if mmDeleteItemsByUserId.funcDeleteItemsByUserId != nil {
		return mmDeleteItemsByUserId.funcDeleteItemsByUserId(ctx, userId)
	}
	mmDeleteItemsByUserId.t.Fatalf("Unexpected call to RepositoryMock.DeleteItemsByUserId. %v %v", ctx, userId)
	return
}

// DeleteItemsByUserIdAfterCounter returns a count of finished RepositoryMock.DeleteItemsByUserId invocations
func (mmDeleteItemsByUserId *RepositoryMock) DeleteItemsByUserIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUserId.afterDeleteItemsByUserIdCounter)
}

// DeleteItemsByUserIdBeforeCounter returns a count of RepositoryMock.DeleteItemsByUserId invocations
func (mmDeleteItemsByUserId *RepositoryMock) DeleteItemsByUserIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUserId.beforeDeleteItemsByUserIdCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteItemsByUserId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItemsByUserId *mRepositoryMockDeleteItemsByUserId) Calls() []*RepositoryMockDeleteItemsByUserIdParams {
	mmDeleteItemsByUserId.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteItemsByUserIdParams, len(mmDeleteItemsByUserId.callArgs))
	copy(argCopy, mmDeleteItemsByUserId.callArgs)

	mmDeleteItemsByUserId.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemsByUserIdDone returns true if the count of the DeleteItemsByUserId invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteItemsByUserIdDone() bool {
	for _, e := range m.DeleteItemsByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemsByUserIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemsByUserId != nil && mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteItemsByUserIdInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteItemsByUserIdInspect() {
	for _, e := range m.DeleteItemsByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItemsByUserId with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemsByUserIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIdCounter) < 1 {
		if m.DeleteItemsByUserIdMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteItemsByUserId")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItemsByUserId with params: %#v", *m.DeleteItemsByUserIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemsByUserId != nil && mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIdCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteItemsByUserId")
	}
}

type mRepositoryMockGetItemsByUserId struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetItemsByUserIdExpectation
	expectations       []*RepositoryMockGetItemsByUserIdExpectation

	callArgs []*RepositoryMockGetItemsByUserIdParams
	mutex    sync.RWMutex
}

// RepositoryMockGetItemsByUserIdExpectation specifies expectation struct of the Repository.GetItemsByUserId
type RepositoryMockGetItemsByUserIdExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetItemsByUserIdParams
	results *RepositoryMockGetItemsByUserIdResults
	Counter uint64
}

// RepositoryMockGetItemsByUserIdParams contains parameters of the Repository.GetItemsByUserId
type RepositoryMockGetItemsByUserIdParams struct {
	ctx    context.Context
	userId int64
}

// RepositoryMockGetItemsByUserIdResults contains results of the Repository.GetItemsByUserId
type RepositoryMockGetItemsByUserIdResults struct {
	i1  domain.ItemsMap
	err error
}

// Expect sets up expected params for Repository.GetItemsByUserId
func (mmGetItemsByUserId *mRepositoryMockGetItemsByUserId) Expect(ctx context.Context, userId int64) *mRepositoryMockGetItemsByUserId {
	if mmGetItemsByUserId.mock.funcGetItemsByUserId != nil {
		mmGetItemsByUserId.mock.t.Fatalf("RepositoryMock.GetItemsByUserId mock is already set by Set")
	}

	if mmGetItemsByUserId.defaultExpectation == nil {
		mmGetItemsByUserId.defaultExpectation = &RepositoryMockGetItemsByUserIdExpectation{}
	}

	mmGetItemsByUserId.defaultExpectation.params = &RepositoryMockGetItemsByUserIdParams{ctx, userId}
	for _, e := range mmGetItemsByUserId.expectations {
		if minimock.Equal(e.params, mmGetItemsByUserId.defaultExpectation.params) {
			mmGetItemsByUserId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemsByUserId.defaultExpectation.params)
		}
	}

	return mmGetItemsByUserId
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetItemsByUserId
func (mmGetItemsByUserId *mRepositoryMockGetItemsByUserId) Inspect(f func(ctx context.Context, userId int64)) *mRepositoryMockGetItemsByUserId {
	if mmGetItemsByUserId.mock.inspectFuncGetItemsByUserId != nil {
		mmGetItemsByUserId.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetItemsByUserId")
	}

	mmGetItemsByUserId.mock.inspectFuncGetItemsByUserId = f

	return mmGetItemsByUserId
}

// Return sets up results that will be returned by Repository.GetItemsByUserId
func (mmGetItemsByUserId *mRepositoryMockGetItemsByUserId) Return(i1 domain.ItemsMap, err error) *RepositoryMock {
	if mmGetItemsByUserId.mock.funcGetItemsByUserId != nil {
		mmGetItemsByUserId.mock.t.Fatalf("RepositoryMock.GetItemsByUserId mock is already set by Set")
	}

	if mmGetItemsByUserId.defaultExpectation == nil {
		mmGetItemsByUserId.defaultExpectation = &RepositoryMockGetItemsByUserIdExpectation{mock: mmGetItemsByUserId.mock}
	}
	mmGetItemsByUserId.defaultExpectation.results = &RepositoryMockGetItemsByUserIdResults{i1, err}
	return mmGetItemsByUserId.mock
}

// Set uses given function f to mock the Repository.GetItemsByUserId method
func (mmGetItemsByUserId *mRepositoryMockGetItemsByUserId) Set(f func(ctx context.Context, userId int64) (i1 domain.ItemsMap, err error)) *RepositoryMock {
	if mmGetItemsByUserId.defaultExpectation != nil {
		mmGetItemsByUserId.mock.t.Fatalf("Default expectation is already set for the Repository.GetItemsByUserId method")
	}

	if len(mmGetItemsByUserId.expectations) > 0 {
		mmGetItemsByUserId.mock.t.Fatalf("Some expectations are already set for the Repository.GetItemsByUserId method")
	}

	mmGetItemsByUserId.mock.funcGetItemsByUserId = f
	return mmGetItemsByUserId.mock
}

// When sets expectation for the Repository.GetItemsByUserId which will trigger the result defined by the following
// Then helper
func (mmGetItemsByUserId *mRepositoryMockGetItemsByUserId) When(ctx context.Context, userId int64) *RepositoryMockGetItemsByUserIdExpectation {
	if mmGetItemsByUserId.mock.funcGetItemsByUserId != nil {
		mmGetItemsByUserId.mock.t.Fatalf("RepositoryMock.GetItemsByUserId mock is already set by Set")
	}

	expectation := &RepositoryMockGetItemsByUserIdExpectation{
		mock:   mmGetItemsByUserId.mock,
		params: &RepositoryMockGetItemsByUserIdParams{ctx, userId},
	}
	mmGetItemsByUserId.expectations = append(mmGetItemsByUserId.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetItemsByUserId return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetItemsByUserIdExpectation) Then(i1 domain.ItemsMap, err error) *RepositoryMock {
	e.results = &RepositoryMockGetItemsByUserIdResults{i1, err}
	return e.mock
}

// GetItemsByUserId implements service.Repository
func (mmGetItemsByUserId *RepositoryMock) GetItemsByUserId(ctx context.Context, userId int64) (i1 domain.ItemsMap, err error) {
	mm_atomic.AddUint64(&mmGetItemsByUserId.beforeGetItemsByUserIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemsByUserId.afterGetItemsByUserIdCounter, 1)

	if mmGetItemsByUserId.inspectFuncGetItemsByUserId != nil {
		mmGetItemsByUserId.inspectFuncGetItemsByUserId(ctx, userId)
	}

	mm_params := RepositoryMockGetItemsByUserIdParams{ctx, userId}

	// Record call args
	mmGetItemsByUserId.GetItemsByUserIdMock.mutex.Lock()
	mmGetItemsByUserId.GetItemsByUserIdMock.callArgs = append(mmGetItemsByUserId.GetItemsByUserIdMock.callArgs, &mm_params)
	mmGetItemsByUserId.GetItemsByUserIdMock.mutex.Unlock()

	for _, e := range mmGetItemsByUserId.GetItemsByUserIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetItemsByUserId.GetItemsByUserIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemsByUserId.GetItemsByUserIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemsByUserId.GetItemsByUserIdMock.defaultExpectation.params
		mm_got := RepositoryMockGetItemsByUserIdParams{ctx, userId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemsByUserId.t.Errorf("RepositoryMock.GetItemsByUserId got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemsByUserId.GetItemsByUserIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemsByUserId.t.Fatal("No results are set for the RepositoryMock.GetItemsByUserId")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetItemsByUserId.funcGetItemsByUserId != nil {
		return mmGetItemsByUserId.funcGetItemsByUserId(ctx, userId)
	}
	mmGetItemsByUserId.t.Fatalf("Unexpected call to RepositoryMock.GetItemsByUserId. %v %v", ctx, userId)
	return
}

// GetItemsByUserIdAfterCounter returns a count of finished RepositoryMock.GetItemsByUserId invocations
func (mmGetItemsByUserId *RepositoryMock) GetItemsByUserIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserId.afterGetItemsByUserIdCounter)
}

// GetItemsByUserIdBeforeCounter returns a count of RepositoryMock.GetItemsByUserId invocations
func (mmGetItemsByUserId *RepositoryMock) GetItemsByUserIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserId.beforeGetItemsByUserIdCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetItemsByUserId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemsByUserId *mRepositoryMockGetItemsByUserId) Calls() []*RepositoryMockGetItemsByUserIdParams {
	mmGetItemsByUserId.mutex.RLock()

	argCopy := make([]*RepositoryMockGetItemsByUserIdParams, len(mmGetItemsByUserId.callArgs))
	copy(argCopy, mmGetItemsByUserId.callArgs)

	mmGetItemsByUserId.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsByUserIdDone returns true if the count of the GetItemsByUserId invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetItemsByUserIdDone() bool {
	for _, e := range m.GetItemsByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByUserIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemsByUserIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByUserId != nil && mm_atomic.LoadUint64(&m.afterGetItemsByUserIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetItemsByUserIdInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetItemsByUserIdInspect() {
	for _, e := range m.GetItemsByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetItemsByUserId with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByUserIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemsByUserIdCounter) < 1 {
		if m.GetItemsByUserIdMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetItemsByUserId")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetItemsByUserId with params: %#v", *m.GetItemsByUserIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByUserId != nil && mm_atomic.LoadUint64(&m.afterGetItemsByUserIdCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetItemsByUserId")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockDeleteItemsByUserIdInspect()

			m.MinimockGetItemsByUserIdInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockDeleteItemsByUserIdDone() &&
		m.MinimockGetItemsByUserIdDone()
}
