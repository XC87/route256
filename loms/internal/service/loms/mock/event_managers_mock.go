// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package order_usecase

//go:generate minimock -i route256.ozon.ru/project/loms/internal/service/loms.EventManagers -o event_managers_mock.go -n EventManagersMock -p order_usecase

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// EventManagersMock implements order_usecase.EventManagers
type EventManagersMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcPublish          func(ctx context.Context, event string, data any) (err error)
	inspectFuncPublish   func(ctx context.Context, event string, data any)
	afterPublishCounter  uint64
	beforePublishCounter uint64
	PublishMock          mEventManagersMockPublish

	funcSubscribe          func(event string, fn func(ctx context.Context, data any))
	inspectFuncSubscribe   func(event string, fn func(ctx context.Context, data any))
	afterSubscribeCounter  uint64
	beforeSubscribeCounter uint64
	SubscribeMock          mEventManagersMockSubscribe
}

// NewEventManagersMock returns a mock for order_usecase.EventManagers
func NewEventManagersMock(t minimock.Tester) *EventManagersMock {
	m := &EventManagersMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.PublishMock = mEventManagersMockPublish{mock: m}
	m.PublishMock.callArgs = []*EventManagersMockPublishParams{}

	m.SubscribeMock = mEventManagersMockSubscribe{mock: m}
	m.SubscribeMock.callArgs = []*EventManagersMockSubscribeParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mEventManagersMockPublish struct {
	mock               *EventManagersMock
	defaultExpectation *EventManagersMockPublishExpectation
	expectations       []*EventManagersMockPublishExpectation

	callArgs []*EventManagersMockPublishParams
	mutex    sync.RWMutex
}

// EventManagersMockPublishExpectation specifies expectation struct of the EventManagers.Publish
type EventManagersMockPublishExpectation struct {
	mock    *EventManagersMock
	params  *EventManagersMockPublishParams
	results *EventManagersMockPublishResults
	Counter uint64
}

// EventManagersMockPublishParams contains parameters of the EventManagers.Publish
type EventManagersMockPublishParams struct {
	ctx   context.Context
	event string
	data  any
}

// EventManagersMockPublishResults contains results of the EventManagers.Publish
type EventManagersMockPublishResults struct {
	err error
}

// Expect sets up expected params for EventManagers.Publish
func (mmPublish *mEventManagersMockPublish) Expect(ctx context.Context, event string, data any) *mEventManagersMockPublish {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("EventManagersMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &EventManagersMockPublishExpectation{}
	}

	mmPublish.defaultExpectation.params = &EventManagersMockPublishParams{ctx, event, data}
	for _, e := range mmPublish.expectations {
		if minimock.Equal(e.params, mmPublish.defaultExpectation.params) {
			mmPublish.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublish.defaultExpectation.params)
		}
	}

	return mmPublish
}

// Inspect accepts an inspector function that has same arguments as the EventManagers.Publish
func (mmPublish *mEventManagersMockPublish) Inspect(f func(ctx context.Context, event string, data any)) *mEventManagersMockPublish {
	if mmPublish.mock.inspectFuncPublish != nil {
		mmPublish.mock.t.Fatalf("Inspect function is already set for EventManagersMock.Publish")
	}

	mmPublish.mock.inspectFuncPublish = f

	return mmPublish
}

// Return sets up results that will be returned by EventManagers.Publish
func (mmPublish *mEventManagersMockPublish) Return(err error) *EventManagersMock {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("EventManagersMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &EventManagersMockPublishExpectation{mock: mmPublish.mock}
	}
	mmPublish.defaultExpectation.results = &EventManagersMockPublishResults{err}
	return mmPublish.mock
}

// Set uses given function f to mock the EventManagers.Publish method
func (mmPublish *mEventManagersMockPublish) Set(f func(ctx context.Context, event string, data any) (err error)) *EventManagersMock {
	if mmPublish.defaultExpectation != nil {
		mmPublish.mock.t.Fatalf("Default expectation is already set for the EventManagers.Publish method")
	}

	if len(mmPublish.expectations) > 0 {
		mmPublish.mock.t.Fatalf("Some expectations are already set for the EventManagers.Publish method")
	}

	mmPublish.mock.funcPublish = f
	return mmPublish.mock
}

// When sets expectation for the EventManagers.Publish which will trigger the result defined by the following
// Then helper
func (mmPublish *mEventManagersMockPublish) When(ctx context.Context, event string, data any) *EventManagersMockPublishExpectation {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("EventManagersMock.Publish mock is already set by Set")
	}

	expectation := &EventManagersMockPublishExpectation{
		mock:   mmPublish.mock,
		params: &EventManagersMockPublishParams{ctx, event, data},
	}
	mmPublish.expectations = append(mmPublish.expectations, expectation)
	return expectation
}

// Then sets up EventManagers.Publish return parameters for the expectation previously defined by the When method
func (e *EventManagersMockPublishExpectation) Then(err error) *EventManagersMock {
	e.results = &EventManagersMockPublishResults{err}
	return e.mock
}

// Publish implements order_usecase.EventManagers
func (mmPublish *EventManagersMock) Publish(ctx context.Context, event string, data any) (err error) {
	mm_atomic.AddUint64(&mmPublish.beforePublishCounter, 1)
	defer mm_atomic.AddUint64(&mmPublish.afterPublishCounter, 1)

	if mmPublish.inspectFuncPublish != nil {
		mmPublish.inspectFuncPublish(ctx, event, data)
	}

	mm_params := EventManagersMockPublishParams{ctx, event, data}

	// Record call args
	mmPublish.PublishMock.mutex.Lock()
	mmPublish.PublishMock.callArgs = append(mmPublish.PublishMock.callArgs, &mm_params)
	mmPublish.PublishMock.mutex.Unlock()

	for _, e := range mmPublish.PublishMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPublish.PublishMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublish.PublishMock.defaultExpectation.Counter, 1)
		mm_want := mmPublish.PublishMock.defaultExpectation.params
		mm_got := EventManagersMockPublishParams{ctx, event, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublish.t.Errorf("EventManagersMock.Publish got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublish.PublishMock.defaultExpectation.results
		if mm_results == nil {
			mmPublish.t.Fatal("No results are set for the EventManagersMock.Publish")
		}
		return (*mm_results).err
	}
	if mmPublish.funcPublish != nil {
		return mmPublish.funcPublish(ctx, event, data)
	}
	mmPublish.t.Fatalf("Unexpected call to EventManagersMock.Publish. %v %v %v", ctx, event, data)
	return
}

// PublishAfterCounter returns a count of finished EventManagersMock.Publish invocations
func (mmPublish *EventManagersMock) PublishAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublish.afterPublishCounter)
}

// PublishBeforeCounter returns a count of EventManagersMock.Publish invocations
func (mmPublish *EventManagersMock) PublishBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublish.beforePublishCounter)
}

// Calls returns a list of arguments used in each call to EventManagersMock.Publish.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublish *mEventManagersMockPublish) Calls() []*EventManagersMockPublishParams {
	mmPublish.mutex.RLock()

	argCopy := make([]*EventManagersMockPublishParams, len(mmPublish.callArgs))
	copy(argCopy, mmPublish.callArgs)

	mmPublish.mutex.RUnlock()

	return argCopy
}

// MinimockPublishDone returns true if the count of the Publish invocations corresponds
// the number of defined expectations
func (m *EventManagersMock) MinimockPublishDone() bool {
	for _, e := range m.PublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublish != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublishInspect logs each unmet expectation
func (m *EventManagersMock) MinimockPublishInspect() {
	for _, e := range m.PublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventManagersMock.Publish with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		if m.PublishMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EventManagersMock.Publish")
		} else {
			m.t.Errorf("Expected call to EventManagersMock.Publish with params: %#v", *m.PublishMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublish != nil && mm_atomic.LoadUint64(&m.afterPublishCounter) < 1 {
		m.t.Error("Expected call to EventManagersMock.Publish")
	}
}

type mEventManagersMockSubscribe struct {
	mock               *EventManagersMock
	defaultExpectation *EventManagersMockSubscribeExpectation
	expectations       []*EventManagersMockSubscribeExpectation

	callArgs []*EventManagersMockSubscribeParams
	mutex    sync.RWMutex
}

// EventManagersMockSubscribeExpectation specifies expectation struct of the EventManagers.Subscribe
type EventManagersMockSubscribeExpectation struct {
	mock   *EventManagersMock
	params *EventManagersMockSubscribeParams

	Counter uint64
}

// EventManagersMockSubscribeParams contains parameters of the EventManagers.Subscribe
type EventManagersMockSubscribeParams struct {
	event string
	fn    func(ctx context.Context, data any)
}

// Expect sets up expected params for EventManagers.Subscribe
func (mmSubscribe *mEventManagersMockSubscribe) Expect(event string, fn func(ctx context.Context, data any)) *mEventManagersMockSubscribe {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("EventManagersMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &EventManagersMockSubscribeExpectation{}
	}

	mmSubscribe.defaultExpectation.params = &EventManagersMockSubscribeParams{event, fn}
	for _, e := range mmSubscribe.expectations {
		if minimock.Equal(e.params, mmSubscribe.defaultExpectation.params) {
			mmSubscribe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSubscribe.defaultExpectation.params)
		}
	}

	return mmSubscribe
}

// Inspect accepts an inspector function that has same arguments as the EventManagers.Subscribe
func (mmSubscribe *mEventManagersMockSubscribe) Inspect(f func(event string, fn func(ctx context.Context, data any))) *mEventManagersMockSubscribe {
	if mmSubscribe.mock.inspectFuncSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("Inspect function is already set for EventManagersMock.Subscribe")
	}

	mmSubscribe.mock.inspectFuncSubscribe = f

	return mmSubscribe
}

// Return sets up results that will be returned by EventManagers.Subscribe
func (mmSubscribe *mEventManagersMockSubscribe) Return() *EventManagersMock {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("EventManagersMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &EventManagersMockSubscribeExpectation{mock: mmSubscribe.mock}
	}

	return mmSubscribe.mock
}

// Set uses given function f to mock the EventManagers.Subscribe method
func (mmSubscribe *mEventManagersMockSubscribe) Set(f func(event string, fn func(ctx context.Context, data any))) *EventManagersMock {
	if mmSubscribe.defaultExpectation != nil {
		mmSubscribe.mock.t.Fatalf("Default expectation is already set for the EventManagers.Subscribe method")
	}

	if len(mmSubscribe.expectations) > 0 {
		mmSubscribe.mock.t.Fatalf("Some expectations are already set for the EventManagers.Subscribe method")
	}

	mmSubscribe.mock.funcSubscribe = f
	return mmSubscribe.mock
}

// Subscribe implements order_usecase.EventManagers
func (mmSubscribe *EventManagersMock) Subscribe(event string, fn func(ctx context.Context, data any)) {
	mm_atomic.AddUint64(&mmSubscribe.beforeSubscribeCounter, 1)
	defer mm_atomic.AddUint64(&mmSubscribe.afterSubscribeCounter, 1)

	if mmSubscribe.inspectFuncSubscribe != nil {
		mmSubscribe.inspectFuncSubscribe(event, fn)
	}

	mm_params := EventManagersMockSubscribeParams{event, fn}

	// Record call args
	mmSubscribe.SubscribeMock.mutex.Lock()
	mmSubscribe.SubscribeMock.callArgs = append(mmSubscribe.SubscribeMock.callArgs, &mm_params)
	mmSubscribe.SubscribeMock.mutex.Unlock()

	for _, e := range mmSubscribe.SubscribeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSubscribe.SubscribeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSubscribe.SubscribeMock.defaultExpectation.Counter, 1)
		mm_want := mmSubscribe.SubscribeMock.defaultExpectation.params
		mm_got := EventManagersMockSubscribeParams{event, fn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSubscribe.t.Errorf("EventManagersMock.Subscribe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSubscribe.funcSubscribe != nil {
		mmSubscribe.funcSubscribe(event, fn)
		return
	}
	mmSubscribe.t.Fatalf("Unexpected call to EventManagersMock.Subscribe. %v %v", event, fn)

}

// SubscribeAfterCounter returns a count of finished EventManagersMock.Subscribe invocations
func (mmSubscribe *EventManagersMock) SubscribeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribe.afterSubscribeCounter)
}

// SubscribeBeforeCounter returns a count of EventManagersMock.Subscribe invocations
func (mmSubscribe *EventManagersMock) SubscribeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribe.beforeSubscribeCounter)
}

// Calls returns a list of arguments used in each call to EventManagersMock.Subscribe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSubscribe *mEventManagersMockSubscribe) Calls() []*EventManagersMockSubscribeParams {
	mmSubscribe.mutex.RLock()

	argCopy := make([]*EventManagersMockSubscribeParams, len(mmSubscribe.callArgs))
	copy(argCopy, mmSubscribe.callArgs)

	mmSubscribe.mutex.RUnlock()

	return argCopy
}

// MinimockSubscribeDone returns true if the count of the Subscribe invocations corresponds
// the number of defined expectations
func (m *EventManagersMock) MinimockSubscribeDone() bool {
	for _, e := range m.SubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribe != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		return false
	}
	return true
}

// MinimockSubscribeInspect logs each unmet expectation
func (m *EventManagersMock) MinimockSubscribeInspect() {
	for _, e := range m.SubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventManagersMock.Subscribe with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		if m.SubscribeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EventManagersMock.Subscribe")
		} else {
			m.t.Errorf("Expected call to EventManagersMock.Subscribe with params: %#v", *m.SubscribeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribe != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		m.t.Error("Expected call to EventManagersMock.Subscribe")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *EventManagersMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockPublishInspect()

			m.MinimockSubscribeInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *EventManagersMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *EventManagersMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockPublishDone() &&
		m.MinimockSubscribeDone()
}
