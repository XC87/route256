// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package order_usecase

//go:generate minimock -i route256.ozon.ru/project/loms/internal/service/loms.EventManagers -o event_managers_mock.go -n EventManagersMock -p order_usecase

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// EventManagersMock implements order_usecase.EventManagers
type EventManagersMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcSubscribe          func(event string, fn func(ctx context.Context, data any) error)
	inspectFuncSubscribe   func(event string, fn func(ctx context.Context, data any) error)
	afterSubscribeCounter  uint64
	beforeSubscribeCounter uint64
	SubscribeMock          mEventManagersMockSubscribe

	funcTrigger          func(ctx context.Context, event string, data any) (err error)
	inspectFuncTrigger   func(ctx context.Context, event string, data any)
	afterTriggerCounter  uint64
	beforeTriggerCounter uint64
	TriggerMock          mEventManagersMockTrigger
}

// NewEventManagersMock returns a mock for order_usecase.EventManagers
func NewEventManagersMock(t minimock.Tester) *EventManagersMock {
	m := &EventManagersMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.SubscribeMock = mEventManagersMockSubscribe{mock: m}
	m.SubscribeMock.callArgs = []*EventManagersMockSubscribeParams{}

	m.TriggerMock = mEventManagersMockTrigger{mock: m}
	m.TriggerMock.callArgs = []*EventManagersMockTriggerParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mEventManagersMockSubscribe struct {
	mock               *EventManagersMock
	defaultExpectation *EventManagersMockSubscribeExpectation
	expectations       []*EventManagersMockSubscribeExpectation

	callArgs []*EventManagersMockSubscribeParams
	mutex    sync.RWMutex
}

// EventManagersMockSubscribeExpectation specifies expectation struct of the EventManagers.Subscribe
type EventManagersMockSubscribeExpectation struct {
	mock   *EventManagersMock
	params *EventManagersMockSubscribeParams

	Counter uint64
}

// EventManagersMockSubscribeParams contains parameters of the EventManagers.Subscribe
type EventManagersMockSubscribeParams struct {
	event string
	fn    func(ctx context.Context, data any) error
}

// Expect sets up expected params for EventManagers.Subscribe
func (mmSubscribe *mEventManagersMockSubscribe) Expect(event string, fn func(ctx context.Context, data any) error) *mEventManagersMockSubscribe {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("EventManagersMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &EventManagersMockSubscribeExpectation{}
	}

	mmSubscribe.defaultExpectation.params = &EventManagersMockSubscribeParams{event, fn}
	for _, e := range mmSubscribe.expectations {
		if minimock.Equal(e.params, mmSubscribe.defaultExpectation.params) {
			mmSubscribe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSubscribe.defaultExpectation.params)
		}
	}

	return mmSubscribe
}

// Inspect accepts an inspector function that has same arguments as the EventManagers.Subscribe
func (mmSubscribe *mEventManagersMockSubscribe) Inspect(f func(event string, fn func(ctx context.Context, data any) error)) *mEventManagersMockSubscribe {
	if mmSubscribe.mock.inspectFuncSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("Inspect function is already set for EventManagersMock.Subscribe")
	}

	mmSubscribe.mock.inspectFuncSubscribe = f

	return mmSubscribe
}

// Return sets up results that will be returned by EventManagers.Subscribe
func (mmSubscribe *mEventManagersMockSubscribe) Return() *EventManagersMock {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("EventManagersMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &EventManagersMockSubscribeExpectation{mock: mmSubscribe.mock}
	}

	return mmSubscribe.mock
}

// Set uses given function f to mock the EventManagers.Subscribe method
func (mmSubscribe *mEventManagersMockSubscribe) Set(f func(event string, fn func(ctx context.Context, data any) error)) *EventManagersMock {
	if mmSubscribe.defaultExpectation != nil {
		mmSubscribe.mock.t.Fatalf("Default expectation is already set for the EventManagers.Subscribe method")
	}

	if len(mmSubscribe.expectations) > 0 {
		mmSubscribe.mock.t.Fatalf("Some expectations are already set for the EventManagers.Subscribe method")
	}

	mmSubscribe.mock.funcSubscribe = f
	return mmSubscribe.mock
}

// Subscribe implements order_usecase.EventManagers
func (mmSubscribe *EventManagersMock) Subscribe(event string, fn func(ctx context.Context, data any) error) {
	mm_atomic.AddUint64(&mmSubscribe.beforeSubscribeCounter, 1)
	defer mm_atomic.AddUint64(&mmSubscribe.afterSubscribeCounter, 1)

	if mmSubscribe.inspectFuncSubscribe != nil {
		mmSubscribe.inspectFuncSubscribe(event, fn)
	}

	mm_params := EventManagersMockSubscribeParams{event, fn}

	// Record call args
	mmSubscribe.SubscribeMock.mutex.Lock()
	mmSubscribe.SubscribeMock.callArgs = append(mmSubscribe.SubscribeMock.callArgs, &mm_params)
	mmSubscribe.SubscribeMock.mutex.Unlock()

	for _, e := range mmSubscribe.SubscribeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSubscribe.SubscribeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSubscribe.SubscribeMock.defaultExpectation.Counter, 1)
		mm_want := mmSubscribe.SubscribeMock.defaultExpectation.params
		mm_got := EventManagersMockSubscribeParams{event, fn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSubscribe.t.Errorf("EventManagersMock.Subscribe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSubscribe.funcSubscribe != nil {
		mmSubscribe.funcSubscribe(event, fn)
		return
	}
	mmSubscribe.t.Fatalf("Unexpected call to EventManagersMock.Subscribe. %v %v", event, fn)

}

// SubscribeAfterCounter returns a count of finished EventManagersMock.Subscribe invocations
func (mmSubscribe *EventManagersMock) SubscribeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribe.afterSubscribeCounter)
}

// SubscribeBeforeCounter returns a count of EventManagersMock.Subscribe invocations
func (mmSubscribe *EventManagersMock) SubscribeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribe.beforeSubscribeCounter)
}

// Calls returns a list of arguments used in each call to EventManagersMock.Subscribe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSubscribe *mEventManagersMockSubscribe) Calls() []*EventManagersMockSubscribeParams {
	mmSubscribe.mutex.RLock()

	argCopy := make([]*EventManagersMockSubscribeParams, len(mmSubscribe.callArgs))
	copy(argCopy, mmSubscribe.callArgs)

	mmSubscribe.mutex.RUnlock()

	return argCopy
}

// MinimockSubscribeDone returns true if the count of the Subscribe invocations corresponds
// the number of defined expectations
func (m *EventManagersMock) MinimockSubscribeDone() bool {
	for _, e := range m.SubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribe != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		return false
	}
	return true
}

// MinimockSubscribeInspect logs each unmet expectation
func (m *EventManagersMock) MinimockSubscribeInspect() {
	for _, e := range m.SubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventManagersMock.Subscribe with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		if m.SubscribeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EventManagersMock.Subscribe")
		} else {
			m.t.Errorf("Expected call to EventManagersMock.Subscribe with params: %#v", *m.SubscribeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribe != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		m.t.Error("Expected call to EventManagersMock.Subscribe")
	}
}

type mEventManagersMockTrigger struct {
	mock               *EventManagersMock
	defaultExpectation *EventManagersMockTriggerExpectation
	expectations       []*EventManagersMockTriggerExpectation

	callArgs []*EventManagersMockTriggerParams
	mutex    sync.RWMutex
}

// EventManagersMockTriggerExpectation specifies expectation struct of the EventManagers.Trigger
type EventManagersMockTriggerExpectation struct {
	mock    *EventManagersMock
	params  *EventManagersMockTriggerParams
	results *EventManagersMockTriggerResults
	Counter uint64
}

// EventManagersMockTriggerParams contains parameters of the EventManagers.Trigger
type EventManagersMockTriggerParams struct {
	ctx   context.Context
	event string
	data  any
}

// EventManagersMockTriggerResults contains results of the EventManagers.Trigger
type EventManagersMockTriggerResults struct {
	err error
}

// Expect sets up expected params for EventManagers.Trigger
func (mmTrigger *mEventManagersMockTrigger) Expect(ctx context.Context, event string, data any) *mEventManagersMockTrigger {
	if mmTrigger.mock.funcTrigger != nil {
		mmTrigger.mock.t.Fatalf("EventManagersMock.Trigger mock is already set by Set")
	}

	if mmTrigger.defaultExpectation == nil {
		mmTrigger.defaultExpectation = &EventManagersMockTriggerExpectation{}
	}

	mmTrigger.defaultExpectation.params = &EventManagersMockTriggerParams{ctx, event, data}
	for _, e := range mmTrigger.expectations {
		if minimock.Equal(e.params, mmTrigger.defaultExpectation.params) {
			mmTrigger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTrigger.defaultExpectation.params)
		}
	}

	return mmTrigger
}

// Inspect accepts an inspector function that has same arguments as the EventManagers.Trigger
func (mmTrigger *mEventManagersMockTrigger) Inspect(f func(ctx context.Context, event string, data any)) *mEventManagersMockTrigger {
	if mmTrigger.mock.inspectFuncTrigger != nil {
		mmTrigger.mock.t.Fatalf("Inspect function is already set for EventManagersMock.Trigger")
	}

	mmTrigger.mock.inspectFuncTrigger = f

	return mmTrigger
}

// Return sets up results that will be returned by EventManagers.Trigger
func (mmTrigger *mEventManagersMockTrigger) Return(err error) *EventManagersMock {
	if mmTrigger.mock.funcTrigger != nil {
		mmTrigger.mock.t.Fatalf("EventManagersMock.Trigger mock is already set by Set")
	}

	if mmTrigger.defaultExpectation == nil {
		mmTrigger.defaultExpectation = &EventManagersMockTriggerExpectation{mock: mmTrigger.mock}
	}
	mmTrigger.defaultExpectation.results = &EventManagersMockTriggerResults{err}
	return mmTrigger.mock
}

// Set uses given function f to mock the EventManagers.Trigger method
func (mmTrigger *mEventManagersMockTrigger) Set(f func(ctx context.Context, event string, data any) (err error)) *EventManagersMock {
	if mmTrigger.defaultExpectation != nil {
		mmTrigger.mock.t.Fatalf("Default expectation is already set for the EventManagers.Trigger method")
	}

	if len(mmTrigger.expectations) > 0 {
		mmTrigger.mock.t.Fatalf("Some expectations are already set for the EventManagers.Trigger method")
	}

	mmTrigger.mock.funcTrigger = f
	return mmTrigger.mock
}

// When sets expectation for the EventManagers.Trigger which will trigger the result defined by the following
// Then helper
func (mmTrigger *mEventManagersMockTrigger) When(ctx context.Context, event string, data any) *EventManagersMockTriggerExpectation {
	if mmTrigger.mock.funcTrigger != nil {
		mmTrigger.mock.t.Fatalf("EventManagersMock.Trigger mock is already set by Set")
	}

	expectation := &EventManagersMockTriggerExpectation{
		mock:   mmTrigger.mock,
		params: &EventManagersMockTriggerParams{ctx, event, data},
	}
	mmTrigger.expectations = append(mmTrigger.expectations, expectation)
	return expectation
}

// Then sets up EventManagers.Trigger return parameters for the expectation previously defined by the When method
func (e *EventManagersMockTriggerExpectation) Then(err error) *EventManagersMock {
	e.results = &EventManagersMockTriggerResults{err}
	return e.mock
}

// Trigger implements order_usecase.EventManagers
func (mmTrigger *EventManagersMock) Trigger(ctx context.Context, event string, data any) (err error) {
	mm_atomic.AddUint64(&mmTrigger.beforeTriggerCounter, 1)
	defer mm_atomic.AddUint64(&mmTrigger.afterTriggerCounter, 1)

	if mmTrigger.inspectFuncTrigger != nil {
		mmTrigger.inspectFuncTrigger(ctx, event, data)
	}

	mm_params := EventManagersMockTriggerParams{ctx, event, data}

	// Record call args
	mmTrigger.TriggerMock.mutex.Lock()
	mmTrigger.TriggerMock.callArgs = append(mmTrigger.TriggerMock.callArgs, &mm_params)
	mmTrigger.TriggerMock.mutex.Unlock()

	for _, e := range mmTrigger.TriggerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTrigger.TriggerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTrigger.TriggerMock.defaultExpectation.Counter, 1)
		mm_want := mmTrigger.TriggerMock.defaultExpectation.params
		mm_got := EventManagersMockTriggerParams{ctx, event, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTrigger.t.Errorf("EventManagersMock.Trigger got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTrigger.TriggerMock.defaultExpectation.results
		if mm_results == nil {
			mmTrigger.t.Fatal("No results are set for the EventManagersMock.Trigger")
		}
		return (*mm_results).err
	}
	if mmTrigger.funcTrigger != nil {
		return mmTrigger.funcTrigger(ctx, event, data)
	}
	mmTrigger.t.Fatalf("Unexpected call to EventManagersMock.Trigger. %v %v %v", ctx, event, data)
	return
}

// TriggerAfterCounter returns a count of finished EventManagersMock.Trigger invocations
func (mmTrigger *EventManagersMock) TriggerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTrigger.afterTriggerCounter)
}

// TriggerBeforeCounter returns a count of EventManagersMock.Trigger invocations
func (mmTrigger *EventManagersMock) TriggerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTrigger.beforeTriggerCounter)
}

// Calls returns a list of arguments used in each call to EventManagersMock.Trigger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTrigger *mEventManagersMockTrigger) Calls() []*EventManagersMockTriggerParams {
	mmTrigger.mutex.RLock()

	argCopy := make([]*EventManagersMockTriggerParams, len(mmTrigger.callArgs))
	copy(argCopy, mmTrigger.callArgs)

	mmTrigger.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerDone returns true if the count of the Trigger invocations corresponds
// the number of defined expectations
func (m *EventManagersMock) MinimockTriggerDone() bool {
	for _, e := range m.TriggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTriggerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTrigger != nil && mm_atomic.LoadUint64(&m.afterTriggerCounter) < 1 {
		return false
	}
	return true
}

// MinimockTriggerInspect logs each unmet expectation
func (m *EventManagersMock) MinimockTriggerInspect() {
	for _, e := range m.TriggerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventManagersMock.Trigger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTriggerCounter) < 1 {
		if m.TriggerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EventManagersMock.Trigger")
		} else {
			m.t.Errorf("Expected call to EventManagersMock.Trigger with params: %#v", *m.TriggerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTrigger != nil && mm_atomic.LoadUint64(&m.afterTriggerCounter) < 1 {
		m.t.Error("Expected call to EventManagersMock.Trigger")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *EventManagersMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockSubscribeInspect()

			m.MinimockTriggerInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *EventManagersMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *EventManagersMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockSubscribeDone() &&
		m.MinimockTriggerDone()
}
