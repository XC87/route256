// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package order_usecase

//go:generate minimock -i route256.ozon.ru/project/loms/internal/service/loms.OrderRepository -o order_repository_mock.go -n OrderRepositoryMock -p order_usecase

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"route256.ozon.ru/project/loms/internal/model"
)

// OrderRepositoryMock implements order_usecase.OrderRepository
type OrderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcOrderCancel          func(ctx context.Context, id int64) (err error)
	inspectFuncOrderCancel   func(ctx context.Context, id int64)
	afterOrderCancelCounter  uint64
	beforeOrderCancelCounter uint64
	OrderCancelMock          mOrderRepositoryMockOrderCancel

	funcOrderCreate          func(ctx context.Context, order *model.Order) (i1 int64, err error)
	inspectFuncOrderCreate   func(ctx context.Context, order *model.Order)
	afterOrderCreateCounter  uint64
	beforeOrderCreateCounter uint64
	OrderCreateMock          mOrderRepositoryMockOrderCreate

	funcOrderInfo          func(ctx context.Context, id int64) (op1 *model.Order, err error)
	inspectFuncOrderInfo   func(ctx context.Context, id int64)
	afterOrderInfoCounter  uint64
	beforeOrderInfoCounter uint64
	OrderInfoMock          mOrderRepositoryMockOrderInfo

	funcOrderPay          func(ctx context.Context, id int64) (err error)
	inspectFuncOrderPay   func(ctx context.Context, id int64)
	afterOrderPayCounter  uint64
	beforeOrderPayCounter uint64
	OrderPayMock          mOrderRepositoryMockOrderPay

	funcOrderUpdate          func(ctx context.Context, order *model.Order) (err error)
	inspectFuncOrderUpdate   func(ctx context.Context, order *model.Order)
	afterOrderUpdateCounter  uint64
	beforeOrderUpdateCounter uint64
	OrderUpdateMock          mOrderRepositoryMockOrderUpdate
}

// NewOrderRepositoryMock returns a mock for order_usecase.OrderRepository
func NewOrderRepositoryMock(t minimock.Tester) *OrderRepositoryMock {
	m := &OrderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.OrderCancelMock = mOrderRepositoryMockOrderCancel{mock: m}
	m.OrderCancelMock.callArgs = []*OrderRepositoryMockOrderCancelParams{}

	m.OrderCreateMock = mOrderRepositoryMockOrderCreate{mock: m}
	m.OrderCreateMock.callArgs = []*OrderRepositoryMockOrderCreateParams{}

	m.OrderInfoMock = mOrderRepositoryMockOrderInfo{mock: m}
	m.OrderInfoMock.callArgs = []*OrderRepositoryMockOrderInfoParams{}

	m.OrderPayMock = mOrderRepositoryMockOrderPay{mock: m}
	m.OrderPayMock.callArgs = []*OrderRepositoryMockOrderPayParams{}

	m.OrderUpdateMock = mOrderRepositoryMockOrderUpdate{mock: m}
	m.OrderUpdateMock.callArgs = []*OrderRepositoryMockOrderUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepositoryMockOrderCancel struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockOrderCancelExpectation
	expectations       []*OrderRepositoryMockOrderCancelExpectation

	callArgs []*OrderRepositoryMockOrderCancelParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockOrderCancelExpectation specifies expectation struct of the OrderRepository.OrderCancel
type OrderRepositoryMockOrderCancelExpectation struct {
	mock    *OrderRepositoryMock
	params  *OrderRepositoryMockOrderCancelParams
	results *OrderRepositoryMockOrderCancelResults
	Counter uint64
}

// OrderRepositoryMockOrderCancelParams contains parameters of the OrderRepository.OrderCancel
type OrderRepositoryMockOrderCancelParams struct {
	ctx context.Context
	id  int64
}

// OrderRepositoryMockOrderCancelResults contains results of the OrderRepository.OrderCancel
type OrderRepositoryMockOrderCancelResults struct {
	err error
}

// Expect sets up expected params for OrderRepository.OrderCancel
func (mmOrderCancel *mOrderRepositoryMockOrderCancel) Expect(ctx context.Context, id int64) *mOrderRepositoryMockOrderCancel {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("OrderRepositoryMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &OrderRepositoryMockOrderCancelExpectation{}
	}

	mmOrderCancel.defaultExpectation.params = &OrderRepositoryMockOrderCancelParams{ctx, id}
	for _, e := range mmOrderCancel.expectations {
		if minimock.Equal(e.params, mmOrderCancel.defaultExpectation.params) {
			mmOrderCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderCancel.defaultExpectation.params)
		}
	}

	return mmOrderCancel
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.OrderCancel
func (mmOrderCancel *mOrderRepositoryMockOrderCancel) Inspect(f func(ctx context.Context, id int64)) *mOrderRepositoryMockOrderCancel {
	if mmOrderCancel.mock.inspectFuncOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.OrderCancel")
	}

	mmOrderCancel.mock.inspectFuncOrderCancel = f

	return mmOrderCancel
}

// Return sets up results that will be returned by OrderRepository.OrderCancel
func (mmOrderCancel *mOrderRepositoryMockOrderCancel) Return(err error) *OrderRepositoryMock {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("OrderRepositoryMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &OrderRepositoryMockOrderCancelExpectation{mock: mmOrderCancel.mock}
	}
	mmOrderCancel.defaultExpectation.results = &OrderRepositoryMockOrderCancelResults{err}
	return mmOrderCancel.mock
}

// Set uses given function f to mock the OrderRepository.OrderCancel method
func (mmOrderCancel *mOrderRepositoryMockOrderCancel) Set(f func(ctx context.Context, id int64) (err error)) *OrderRepositoryMock {
	if mmOrderCancel.defaultExpectation != nil {
		mmOrderCancel.mock.t.Fatalf("Default expectation is already set for the OrderRepository.OrderCancel method")
	}

	if len(mmOrderCancel.expectations) > 0 {
		mmOrderCancel.mock.t.Fatalf("Some expectations are already set for the OrderRepository.OrderCancel method")
	}

	mmOrderCancel.mock.funcOrderCancel = f
	return mmOrderCancel.mock
}

// When sets expectation for the OrderRepository.OrderCancel which will trigger the result defined by the following
// Then helper
func (mmOrderCancel *mOrderRepositoryMockOrderCancel) When(ctx context.Context, id int64) *OrderRepositoryMockOrderCancelExpectation {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("OrderRepositoryMock.OrderCancel mock is already set by Set")
	}

	expectation := &OrderRepositoryMockOrderCancelExpectation{
		mock:   mmOrderCancel.mock,
		params: &OrderRepositoryMockOrderCancelParams{ctx, id},
	}
	mmOrderCancel.expectations = append(mmOrderCancel.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.OrderCancel return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockOrderCancelExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockOrderCancelResults{err}
	return e.mock
}

// OrderCancel implements order_usecase.OrderRepository
func (mmOrderCancel *OrderRepositoryMock) OrderCancel(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmOrderCancel.beforeOrderCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderCancel.afterOrderCancelCounter, 1)

	if mmOrderCancel.inspectFuncOrderCancel != nil {
		mmOrderCancel.inspectFuncOrderCancel(ctx, id)
	}

	mm_params := OrderRepositoryMockOrderCancelParams{ctx, id}

	// Record call args
	mmOrderCancel.OrderCancelMock.mutex.Lock()
	mmOrderCancel.OrderCancelMock.callArgs = append(mmOrderCancel.OrderCancelMock.callArgs, &mm_params)
	mmOrderCancel.OrderCancelMock.mutex.Unlock()

	for _, e := range mmOrderCancel.OrderCancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderCancel.OrderCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderCancel.OrderCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderCancel.OrderCancelMock.defaultExpectation.params
		mm_got := OrderRepositoryMockOrderCancelParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderCancel.t.Errorf("OrderRepositoryMock.OrderCancel got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderCancel.OrderCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderCancel.t.Fatal("No results are set for the OrderRepositoryMock.OrderCancel")
		}
		return (*mm_results).err
	}
	if mmOrderCancel.funcOrderCancel != nil {
		return mmOrderCancel.funcOrderCancel(ctx, id)
	}
	mmOrderCancel.t.Fatalf("Unexpected call to OrderRepositoryMock.OrderCancel. %v %v", ctx, id)
	return
}

// OrderCancelAfterCounter returns a count of finished OrderRepositoryMock.OrderCancel invocations
func (mmOrderCancel *OrderRepositoryMock) OrderCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCancel.afterOrderCancelCounter)
}

// OrderCancelBeforeCounter returns a count of OrderRepositoryMock.OrderCancel invocations
func (mmOrderCancel *OrderRepositoryMock) OrderCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCancel.beforeOrderCancelCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.OrderCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderCancel *mOrderRepositoryMockOrderCancel) Calls() []*OrderRepositoryMockOrderCancelParams {
	mmOrderCancel.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockOrderCancelParams, len(mmOrderCancel.callArgs))
	copy(argCopy, mmOrderCancel.callArgs)

	mmOrderCancel.mutex.RUnlock()

	return argCopy
}

// MinimockOrderCancelDone returns true if the count of the OrderCancel invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockOrderCancelDone() bool {
	for _, e := range m.OrderCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCancelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderCancelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCancel != nil && mm_atomic.LoadUint64(&m.afterOrderCancelCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderCancelInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockOrderCancelInspect() {
	for _, e := range m.OrderCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.OrderCancel with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCancelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderCancelCounter) < 1 {
		if m.OrderCancelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.OrderCancel")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.OrderCancel with params: %#v", *m.OrderCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCancel != nil && mm_atomic.LoadUint64(&m.afterOrderCancelCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.OrderCancel")
	}
}

type mOrderRepositoryMockOrderCreate struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockOrderCreateExpectation
	expectations       []*OrderRepositoryMockOrderCreateExpectation

	callArgs []*OrderRepositoryMockOrderCreateParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockOrderCreateExpectation specifies expectation struct of the OrderRepository.OrderCreate
type OrderRepositoryMockOrderCreateExpectation struct {
	mock    *OrderRepositoryMock
	params  *OrderRepositoryMockOrderCreateParams
	results *OrderRepositoryMockOrderCreateResults
	Counter uint64
}

// OrderRepositoryMockOrderCreateParams contains parameters of the OrderRepository.OrderCreate
type OrderRepositoryMockOrderCreateParams struct {
	ctx   context.Context
	order *model.Order
}

// OrderRepositoryMockOrderCreateResults contains results of the OrderRepository.OrderCreate
type OrderRepositoryMockOrderCreateResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for OrderRepository.OrderCreate
func (mmOrderCreate *mOrderRepositoryMockOrderCreate) Expect(ctx context.Context, order *model.Order) *mOrderRepositoryMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("OrderRepositoryMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &OrderRepositoryMockOrderCreateExpectation{}
	}

	mmOrderCreate.defaultExpectation.params = &OrderRepositoryMockOrderCreateParams{ctx, order}
	for _, e := range mmOrderCreate.expectations {
		if minimock.Equal(e.params, mmOrderCreate.defaultExpectation.params) {
			mmOrderCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderCreate.defaultExpectation.params)
		}
	}

	return mmOrderCreate
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.OrderCreate
func (mmOrderCreate *mOrderRepositoryMockOrderCreate) Inspect(f func(ctx context.Context, order *model.Order)) *mOrderRepositoryMockOrderCreate {
	if mmOrderCreate.mock.inspectFuncOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.OrderCreate")
	}

	mmOrderCreate.mock.inspectFuncOrderCreate = f

	return mmOrderCreate
}

// Return sets up results that will be returned by OrderRepository.OrderCreate
func (mmOrderCreate *mOrderRepositoryMockOrderCreate) Return(i1 int64, err error) *OrderRepositoryMock {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("OrderRepositoryMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &OrderRepositoryMockOrderCreateExpectation{mock: mmOrderCreate.mock}
	}
	mmOrderCreate.defaultExpectation.results = &OrderRepositoryMockOrderCreateResults{i1, err}
	return mmOrderCreate.mock
}

// Set uses given function f to mock the OrderRepository.OrderCreate method
func (mmOrderCreate *mOrderRepositoryMockOrderCreate) Set(f func(ctx context.Context, order *model.Order) (i1 int64, err error)) *OrderRepositoryMock {
	if mmOrderCreate.defaultExpectation != nil {
		mmOrderCreate.mock.t.Fatalf("Default expectation is already set for the OrderRepository.OrderCreate method")
	}

	if len(mmOrderCreate.expectations) > 0 {
		mmOrderCreate.mock.t.Fatalf("Some expectations are already set for the OrderRepository.OrderCreate method")
	}

	mmOrderCreate.mock.funcOrderCreate = f
	return mmOrderCreate.mock
}

// When sets expectation for the OrderRepository.OrderCreate which will trigger the result defined by the following
// Then helper
func (mmOrderCreate *mOrderRepositoryMockOrderCreate) When(ctx context.Context, order *model.Order) *OrderRepositoryMockOrderCreateExpectation {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("OrderRepositoryMock.OrderCreate mock is already set by Set")
	}

	expectation := &OrderRepositoryMockOrderCreateExpectation{
		mock:   mmOrderCreate.mock,
		params: &OrderRepositoryMockOrderCreateParams{ctx, order},
	}
	mmOrderCreate.expectations = append(mmOrderCreate.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.OrderCreate return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockOrderCreateExpectation) Then(i1 int64, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockOrderCreateResults{i1, err}
	return e.mock
}

// OrderCreate implements order_usecase.OrderRepository
func (mmOrderCreate *OrderRepositoryMock) OrderCreate(ctx context.Context, order *model.Order) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmOrderCreate.beforeOrderCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderCreate.afterOrderCreateCounter, 1)

	if mmOrderCreate.inspectFuncOrderCreate != nil {
		mmOrderCreate.inspectFuncOrderCreate(ctx, order)
	}

	mm_params := OrderRepositoryMockOrderCreateParams{ctx, order}

	// Record call args
	mmOrderCreate.OrderCreateMock.mutex.Lock()
	mmOrderCreate.OrderCreateMock.callArgs = append(mmOrderCreate.OrderCreateMock.callArgs, &mm_params)
	mmOrderCreate.OrderCreateMock.mutex.Unlock()

	for _, e := range mmOrderCreate.OrderCreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmOrderCreate.OrderCreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderCreate.OrderCreateMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderCreate.OrderCreateMock.defaultExpectation.params
		mm_got := OrderRepositoryMockOrderCreateParams{ctx, order}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderCreate.t.Errorf("OrderRepositoryMock.OrderCreate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderCreate.OrderCreateMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderCreate.t.Fatal("No results are set for the OrderRepositoryMock.OrderCreate")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmOrderCreate.funcOrderCreate != nil {
		return mmOrderCreate.funcOrderCreate(ctx, order)
	}
	mmOrderCreate.t.Fatalf("Unexpected call to OrderRepositoryMock.OrderCreate. %v %v", ctx, order)
	return
}

// OrderCreateAfterCounter returns a count of finished OrderRepositoryMock.OrderCreate invocations
func (mmOrderCreate *OrderRepositoryMock) OrderCreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreate.afterOrderCreateCounter)
}

// OrderCreateBeforeCounter returns a count of OrderRepositoryMock.OrderCreate invocations
func (mmOrderCreate *OrderRepositoryMock) OrderCreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreate.beforeOrderCreateCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.OrderCreate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderCreate *mOrderRepositoryMockOrderCreate) Calls() []*OrderRepositoryMockOrderCreateParams {
	mmOrderCreate.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockOrderCreateParams, len(mmOrderCreate.callArgs))
	copy(argCopy, mmOrderCreate.callArgs)

	mmOrderCreate.mutex.RUnlock()

	return argCopy
}

// MinimockOrderCreateDone returns true if the count of the OrderCreate invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockOrderCreateDone() bool {
	for _, e := range m.OrderCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCreate != nil && mm_atomic.LoadUint64(&m.afterOrderCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderCreateInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockOrderCreateInspect() {
	for _, e := range m.OrderCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.OrderCreate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderCreateCounter) < 1 {
		if m.OrderCreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.OrderCreate")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.OrderCreate with params: %#v", *m.OrderCreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCreate != nil && mm_atomic.LoadUint64(&m.afterOrderCreateCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.OrderCreate")
	}
}

type mOrderRepositoryMockOrderInfo struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockOrderInfoExpectation
	expectations       []*OrderRepositoryMockOrderInfoExpectation

	callArgs []*OrderRepositoryMockOrderInfoParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockOrderInfoExpectation specifies expectation struct of the OrderRepository.OrderInfo
type OrderRepositoryMockOrderInfoExpectation struct {
	mock    *OrderRepositoryMock
	params  *OrderRepositoryMockOrderInfoParams
	results *OrderRepositoryMockOrderInfoResults
	Counter uint64
}

// OrderRepositoryMockOrderInfoParams contains parameters of the OrderRepository.OrderInfo
type OrderRepositoryMockOrderInfoParams struct {
	ctx context.Context
	id  int64
}

// OrderRepositoryMockOrderInfoResults contains results of the OrderRepository.OrderInfo
type OrderRepositoryMockOrderInfoResults struct {
	op1 *model.Order
	err error
}

// Expect sets up expected params for OrderRepository.OrderInfo
func (mmOrderInfo *mOrderRepositoryMockOrderInfo) Expect(ctx context.Context, id int64) *mOrderRepositoryMockOrderInfo {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("OrderRepositoryMock.OrderInfo mock is already set by Set")
	}

	if mmOrderInfo.defaultExpectation == nil {
		mmOrderInfo.defaultExpectation = &OrderRepositoryMockOrderInfoExpectation{}
	}

	mmOrderInfo.defaultExpectation.params = &OrderRepositoryMockOrderInfoParams{ctx, id}
	for _, e := range mmOrderInfo.expectations {
		if minimock.Equal(e.params, mmOrderInfo.defaultExpectation.params) {
			mmOrderInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderInfo.defaultExpectation.params)
		}
	}

	return mmOrderInfo
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.OrderInfo
func (mmOrderInfo *mOrderRepositoryMockOrderInfo) Inspect(f func(ctx context.Context, id int64)) *mOrderRepositoryMockOrderInfo {
	if mmOrderInfo.mock.inspectFuncOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.OrderInfo")
	}

	mmOrderInfo.mock.inspectFuncOrderInfo = f

	return mmOrderInfo
}

// Return sets up results that will be returned by OrderRepository.OrderInfo
func (mmOrderInfo *mOrderRepositoryMockOrderInfo) Return(op1 *model.Order, err error) *OrderRepositoryMock {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("OrderRepositoryMock.OrderInfo mock is already set by Set")
	}

	if mmOrderInfo.defaultExpectation == nil {
		mmOrderInfo.defaultExpectation = &OrderRepositoryMockOrderInfoExpectation{mock: mmOrderInfo.mock}
	}
	mmOrderInfo.defaultExpectation.results = &OrderRepositoryMockOrderInfoResults{op1, err}
	return mmOrderInfo.mock
}

// Set uses given function f to mock the OrderRepository.OrderInfo method
func (mmOrderInfo *mOrderRepositoryMockOrderInfo) Set(f func(ctx context.Context, id int64) (op1 *model.Order, err error)) *OrderRepositoryMock {
	if mmOrderInfo.defaultExpectation != nil {
		mmOrderInfo.mock.t.Fatalf("Default expectation is already set for the OrderRepository.OrderInfo method")
	}

	if len(mmOrderInfo.expectations) > 0 {
		mmOrderInfo.mock.t.Fatalf("Some expectations are already set for the OrderRepository.OrderInfo method")
	}

	mmOrderInfo.mock.funcOrderInfo = f
	return mmOrderInfo.mock
}

// When sets expectation for the OrderRepository.OrderInfo which will trigger the result defined by the following
// Then helper
func (mmOrderInfo *mOrderRepositoryMockOrderInfo) When(ctx context.Context, id int64) *OrderRepositoryMockOrderInfoExpectation {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("OrderRepositoryMock.OrderInfo mock is already set by Set")
	}

	expectation := &OrderRepositoryMockOrderInfoExpectation{
		mock:   mmOrderInfo.mock,
		params: &OrderRepositoryMockOrderInfoParams{ctx, id},
	}
	mmOrderInfo.expectations = append(mmOrderInfo.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.OrderInfo return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockOrderInfoExpectation) Then(op1 *model.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockOrderInfoResults{op1, err}
	return e.mock
}

// OrderInfo implements order_usecase.OrderRepository
func (mmOrderInfo *OrderRepositoryMock) OrderInfo(ctx context.Context, id int64) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmOrderInfo.beforeOrderInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderInfo.afterOrderInfoCounter, 1)

	if mmOrderInfo.inspectFuncOrderInfo != nil {
		mmOrderInfo.inspectFuncOrderInfo(ctx, id)
	}

	mm_params := OrderRepositoryMockOrderInfoParams{ctx, id}

	// Record call args
	mmOrderInfo.OrderInfoMock.mutex.Lock()
	mmOrderInfo.OrderInfoMock.callArgs = append(mmOrderInfo.OrderInfoMock.callArgs, &mm_params)
	mmOrderInfo.OrderInfoMock.mutex.Unlock()

	for _, e := range mmOrderInfo.OrderInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmOrderInfo.OrderInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderInfo.OrderInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderInfo.OrderInfoMock.defaultExpectation.params
		mm_got := OrderRepositoryMockOrderInfoParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderInfo.t.Errorf("OrderRepositoryMock.OrderInfo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderInfo.OrderInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderInfo.t.Fatal("No results are set for the OrderRepositoryMock.OrderInfo")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmOrderInfo.funcOrderInfo != nil {
		return mmOrderInfo.funcOrderInfo(ctx, id)
	}
	mmOrderInfo.t.Fatalf("Unexpected call to OrderRepositoryMock.OrderInfo. %v %v", ctx, id)
	return
}

// OrderInfoAfterCounter returns a count of finished OrderRepositoryMock.OrderInfo invocations
func (mmOrderInfo *OrderRepositoryMock) OrderInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderInfo.afterOrderInfoCounter)
}

// OrderInfoBeforeCounter returns a count of OrderRepositoryMock.OrderInfo invocations
func (mmOrderInfo *OrderRepositoryMock) OrderInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderInfo.beforeOrderInfoCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.OrderInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderInfo *mOrderRepositoryMockOrderInfo) Calls() []*OrderRepositoryMockOrderInfoParams {
	mmOrderInfo.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockOrderInfoParams, len(mmOrderInfo.callArgs))
	copy(argCopy, mmOrderInfo.callArgs)

	mmOrderInfo.mutex.RUnlock()

	return argCopy
}

// MinimockOrderInfoDone returns true if the count of the OrderInfo invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockOrderInfoDone() bool {
	for _, e := range m.OrderInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderInfo != nil && mm_atomic.LoadUint64(&m.afterOrderInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderInfoInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockOrderInfoInspect() {
	for _, e := range m.OrderInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.OrderInfo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderInfoCounter) < 1 {
		if m.OrderInfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.OrderInfo")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.OrderInfo with params: %#v", *m.OrderInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderInfo != nil && mm_atomic.LoadUint64(&m.afterOrderInfoCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.OrderInfo")
	}
}

type mOrderRepositoryMockOrderPay struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockOrderPayExpectation
	expectations       []*OrderRepositoryMockOrderPayExpectation

	callArgs []*OrderRepositoryMockOrderPayParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockOrderPayExpectation specifies expectation struct of the OrderRepository.OrderPay
type OrderRepositoryMockOrderPayExpectation struct {
	mock    *OrderRepositoryMock
	params  *OrderRepositoryMockOrderPayParams
	results *OrderRepositoryMockOrderPayResults
	Counter uint64
}

// OrderRepositoryMockOrderPayParams contains parameters of the OrderRepository.OrderPay
type OrderRepositoryMockOrderPayParams struct {
	ctx context.Context
	id  int64
}

// OrderRepositoryMockOrderPayResults contains results of the OrderRepository.OrderPay
type OrderRepositoryMockOrderPayResults struct {
	err error
}

// Expect sets up expected params for OrderRepository.OrderPay
func (mmOrderPay *mOrderRepositoryMockOrderPay) Expect(ctx context.Context, id int64) *mOrderRepositoryMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("OrderRepositoryMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &OrderRepositoryMockOrderPayExpectation{}
	}

	mmOrderPay.defaultExpectation.params = &OrderRepositoryMockOrderPayParams{ctx, id}
	for _, e := range mmOrderPay.expectations {
		if minimock.Equal(e.params, mmOrderPay.defaultExpectation.params) {
			mmOrderPay.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderPay.defaultExpectation.params)
		}
	}

	return mmOrderPay
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.OrderPay
func (mmOrderPay *mOrderRepositoryMockOrderPay) Inspect(f func(ctx context.Context, id int64)) *mOrderRepositoryMockOrderPay {
	if mmOrderPay.mock.inspectFuncOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.OrderPay")
	}

	mmOrderPay.mock.inspectFuncOrderPay = f

	return mmOrderPay
}

// Return sets up results that will be returned by OrderRepository.OrderPay
func (mmOrderPay *mOrderRepositoryMockOrderPay) Return(err error) *OrderRepositoryMock {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("OrderRepositoryMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &OrderRepositoryMockOrderPayExpectation{mock: mmOrderPay.mock}
	}
	mmOrderPay.defaultExpectation.results = &OrderRepositoryMockOrderPayResults{err}
	return mmOrderPay.mock
}

// Set uses given function f to mock the OrderRepository.OrderPay method
func (mmOrderPay *mOrderRepositoryMockOrderPay) Set(f func(ctx context.Context, id int64) (err error)) *OrderRepositoryMock {
	if mmOrderPay.defaultExpectation != nil {
		mmOrderPay.mock.t.Fatalf("Default expectation is already set for the OrderRepository.OrderPay method")
	}

	if len(mmOrderPay.expectations) > 0 {
		mmOrderPay.mock.t.Fatalf("Some expectations are already set for the OrderRepository.OrderPay method")
	}

	mmOrderPay.mock.funcOrderPay = f
	return mmOrderPay.mock
}

// When sets expectation for the OrderRepository.OrderPay which will trigger the result defined by the following
// Then helper
func (mmOrderPay *mOrderRepositoryMockOrderPay) When(ctx context.Context, id int64) *OrderRepositoryMockOrderPayExpectation {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("OrderRepositoryMock.OrderPay mock is already set by Set")
	}

	expectation := &OrderRepositoryMockOrderPayExpectation{
		mock:   mmOrderPay.mock,
		params: &OrderRepositoryMockOrderPayParams{ctx, id},
	}
	mmOrderPay.expectations = append(mmOrderPay.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.OrderPay return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockOrderPayExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockOrderPayResults{err}
	return e.mock
}

// OrderPay implements order_usecase.OrderRepository
func (mmOrderPay *OrderRepositoryMock) OrderPay(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmOrderPay.beforeOrderPayCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderPay.afterOrderPayCounter, 1)

	if mmOrderPay.inspectFuncOrderPay != nil {
		mmOrderPay.inspectFuncOrderPay(ctx, id)
	}

	mm_params := OrderRepositoryMockOrderPayParams{ctx, id}

	// Record call args
	mmOrderPay.OrderPayMock.mutex.Lock()
	mmOrderPay.OrderPayMock.callArgs = append(mmOrderPay.OrderPayMock.callArgs, &mm_params)
	mmOrderPay.OrderPayMock.mutex.Unlock()

	for _, e := range mmOrderPay.OrderPayMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderPay.OrderPayMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderPay.OrderPayMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderPay.OrderPayMock.defaultExpectation.params
		mm_got := OrderRepositoryMockOrderPayParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderPay.t.Errorf("OrderRepositoryMock.OrderPay got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderPay.OrderPayMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderPay.t.Fatal("No results are set for the OrderRepositoryMock.OrderPay")
		}
		return (*mm_results).err
	}
	if mmOrderPay.funcOrderPay != nil {
		return mmOrderPay.funcOrderPay(ctx, id)
	}
	mmOrderPay.t.Fatalf("Unexpected call to OrderRepositoryMock.OrderPay. %v %v", ctx, id)
	return
}

// OrderPayAfterCounter returns a count of finished OrderRepositoryMock.OrderPay invocations
func (mmOrderPay *OrderRepositoryMock) OrderPayAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPay.afterOrderPayCounter)
}

// OrderPayBeforeCounter returns a count of OrderRepositoryMock.OrderPay invocations
func (mmOrderPay *OrderRepositoryMock) OrderPayBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPay.beforeOrderPayCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.OrderPay.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderPay *mOrderRepositoryMockOrderPay) Calls() []*OrderRepositoryMockOrderPayParams {
	mmOrderPay.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockOrderPayParams, len(mmOrderPay.callArgs))
	copy(argCopy, mmOrderPay.callArgs)

	mmOrderPay.mutex.RUnlock()

	return argCopy
}

// MinimockOrderPayDone returns true if the count of the OrderPay invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockOrderPayDone() bool {
	for _, e := range m.OrderPayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderPayMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderPayCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderPay != nil && mm_atomic.LoadUint64(&m.afterOrderPayCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderPayInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockOrderPayInspect() {
	for _, e := range m.OrderPayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.OrderPay with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderPayMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderPayCounter) < 1 {
		if m.OrderPayMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.OrderPay")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.OrderPay with params: %#v", *m.OrderPayMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderPay != nil && mm_atomic.LoadUint64(&m.afterOrderPayCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.OrderPay")
	}
}

type mOrderRepositoryMockOrderUpdate struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockOrderUpdateExpectation
	expectations       []*OrderRepositoryMockOrderUpdateExpectation

	callArgs []*OrderRepositoryMockOrderUpdateParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockOrderUpdateExpectation specifies expectation struct of the OrderRepository.OrderUpdate
type OrderRepositoryMockOrderUpdateExpectation struct {
	mock    *OrderRepositoryMock
	params  *OrderRepositoryMockOrderUpdateParams
	results *OrderRepositoryMockOrderUpdateResults
	Counter uint64
}

// OrderRepositoryMockOrderUpdateParams contains parameters of the OrderRepository.OrderUpdate
type OrderRepositoryMockOrderUpdateParams struct {
	ctx   context.Context
	order *model.Order
}

// OrderRepositoryMockOrderUpdateResults contains results of the OrderRepository.OrderUpdate
type OrderRepositoryMockOrderUpdateResults struct {
	err error
}

// Expect sets up expected params for OrderRepository.OrderUpdate
func (mmOrderUpdate *mOrderRepositoryMockOrderUpdate) Expect(ctx context.Context, order *model.Order) *mOrderRepositoryMockOrderUpdate {
	if mmOrderUpdate.mock.funcOrderUpdate != nil {
		mmOrderUpdate.mock.t.Fatalf("OrderRepositoryMock.OrderUpdate mock is already set by Set")
	}

	if mmOrderUpdate.defaultExpectation == nil {
		mmOrderUpdate.defaultExpectation = &OrderRepositoryMockOrderUpdateExpectation{}
	}

	mmOrderUpdate.defaultExpectation.params = &OrderRepositoryMockOrderUpdateParams{ctx, order}
	for _, e := range mmOrderUpdate.expectations {
		if minimock.Equal(e.params, mmOrderUpdate.defaultExpectation.params) {
			mmOrderUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderUpdate.defaultExpectation.params)
		}
	}

	return mmOrderUpdate
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.OrderUpdate
func (mmOrderUpdate *mOrderRepositoryMockOrderUpdate) Inspect(f func(ctx context.Context, order *model.Order)) *mOrderRepositoryMockOrderUpdate {
	if mmOrderUpdate.mock.inspectFuncOrderUpdate != nil {
		mmOrderUpdate.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.OrderUpdate")
	}

	mmOrderUpdate.mock.inspectFuncOrderUpdate = f

	return mmOrderUpdate
}

// Return sets up results that will be returned by OrderRepository.OrderUpdate
func (mmOrderUpdate *mOrderRepositoryMockOrderUpdate) Return(err error) *OrderRepositoryMock {
	if mmOrderUpdate.mock.funcOrderUpdate != nil {
		mmOrderUpdate.mock.t.Fatalf("OrderRepositoryMock.OrderUpdate mock is already set by Set")
	}

	if mmOrderUpdate.defaultExpectation == nil {
		mmOrderUpdate.defaultExpectation = &OrderRepositoryMockOrderUpdateExpectation{mock: mmOrderUpdate.mock}
	}
	mmOrderUpdate.defaultExpectation.results = &OrderRepositoryMockOrderUpdateResults{err}
	return mmOrderUpdate.mock
}

// Set uses given function f to mock the OrderRepository.OrderUpdate method
func (mmOrderUpdate *mOrderRepositoryMockOrderUpdate) Set(f func(ctx context.Context, order *model.Order) (err error)) *OrderRepositoryMock {
	if mmOrderUpdate.defaultExpectation != nil {
		mmOrderUpdate.mock.t.Fatalf("Default expectation is already set for the OrderRepository.OrderUpdate method")
	}

	if len(mmOrderUpdate.expectations) > 0 {
		mmOrderUpdate.mock.t.Fatalf("Some expectations are already set for the OrderRepository.OrderUpdate method")
	}

	mmOrderUpdate.mock.funcOrderUpdate = f
	return mmOrderUpdate.mock
}

// When sets expectation for the OrderRepository.OrderUpdate which will trigger the result defined by the following
// Then helper
func (mmOrderUpdate *mOrderRepositoryMockOrderUpdate) When(ctx context.Context, order *model.Order) *OrderRepositoryMockOrderUpdateExpectation {
	if mmOrderUpdate.mock.funcOrderUpdate != nil {
		mmOrderUpdate.mock.t.Fatalf("OrderRepositoryMock.OrderUpdate mock is already set by Set")
	}

	expectation := &OrderRepositoryMockOrderUpdateExpectation{
		mock:   mmOrderUpdate.mock,
		params: &OrderRepositoryMockOrderUpdateParams{ctx, order},
	}
	mmOrderUpdate.expectations = append(mmOrderUpdate.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.OrderUpdate return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockOrderUpdateExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockOrderUpdateResults{err}
	return e.mock
}

// OrderUpdate implements order_usecase.OrderRepository
func (mmOrderUpdate *OrderRepositoryMock) OrderUpdate(ctx context.Context, order *model.Order) (err error) {
	mm_atomic.AddUint64(&mmOrderUpdate.beforeOrderUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderUpdate.afterOrderUpdateCounter, 1)

	if mmOrderUpdate.inspectFuncOrderUpdate != nil {
		mmOrderUpdate.inspectFuncOrderUpdate(ctx, order)
	}

	mm_params := OrderRepositoryMockOrderUpdateParams{ctx, order}

	// Record call args
	mmOrderUpdate.OrderUpdateMock.mutex.Lock()
	mmOrderUpdate.OrderUpdateMock.callArgs = append(mmOrderUpdate.OrderUpdateMock.callArgs, &mm_params)
	mmOrderUpdate.OrderUpdateMock.mutex.Unlock()

	for _, e := range mmOrderUpdate.OrderUpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderUpdate.OrderUpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderUpdate.OrderUpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderUpdate.OrderUpdateMock.defaultExpectation.params
		mm_got := OrderRepositoryMockOrderUpdateParams{ctx, order}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderUpdate.t.Errorf("OrderRepositoryMock.OrderUpdate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderUpdate.OrderUpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderUpdate.t.Fatal("No results are set for the OrderRepositoryMock.OrderUpdate")
		}
		return (*mm_results).err
	}
	if mmOrderUpdate.funcOrderUpdate != nil {
		return mmOrderUpdate.funcOrderUpdate(ctx, order)
	}
	mmOrderUpdate.t.Fatalf("Unexpected call to OrderRepositoryMock.OrderUpdate. %v %v", ctx, order)
	return
}

// OrderUpdateAfterCounter returns a count of finished OrderRepositoryMock.OrderUpdate invocations
func (mmOrderUpdate *OrderRepositoryMock) OrderUpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderUpdate.afterOrderUpdateCounter)
}

// OrderUpdateBeforeCounter returns a count of OrderRepositoryMock.OrderUpdate invocations
func (mmOrderUpdate *OrderRepositoryMock) OrderUpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderUpdate.beforeOrderUpdateCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.OrderUpdate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderUpdate *mOrderRepositoryMockOrderUpdate) Calls() []*OrderRepositoryMockOrderUpdateParams {
	mmOrderUpdate.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockOrderUpdateParams, len(mmOrderUpdate.callArgs))
	copy(argCopy, mmOrderUpdate.callArgs)

	mmOrderUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockOrderUpdateDone returns true if the count of the OrderUpdate invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockOrderUpdateDone() bool {
	for _, e := range m.OrderUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderUpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderUpdate != nil && mm_atomic.LoadUint64(&m.afterOrderUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderUpdateInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockOrderUpdateInspect() {
	for _, e := range m.OrderUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.OrderUpdate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderUpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderUpdateCounter) < 1 {
		if m.OrderUpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.OrderUpdate")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.OrderUpdate with params: %#v", *m.OrderUpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderUpdate != nil && mm_atomic.LoadUint64(&m.afterOrderUpdateCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.OrderUpdate")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockOrderCancelInspect()

			m.MinimockOrderCreateInspect()

			m.MinimockOrderInfoInspect()

			m.MinimockOrderPayInspect()

			m.MinimockOrderUpdateInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockOrderCancelDone() &&
		m.MinimockOrderCreateDone() &&
		m.MinimockOrderInfoDone() &&
		m.MinimockOrderPayDone() &&
		m.MinimockOrderUpdateDone()
}
