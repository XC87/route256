// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package order_usecase

//go:generate minimock -i route256.ozon.ru/project/loms/internal/service/loms.StockRepository -o stock_repository_mock.go -n StockRepositoryMock -p order_usecase

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"route256.ozon.ru/project/loms/internal/model"
	stock_repository "route256.ozon.ru/project/loms/internal/repository/stock"
)

// StockRepositoryMock implements order_usecase.StockRepository
type StockRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetBySku          func(ctx context.Context, sku uint32) (p1 stock_repository.Product, err error)
	inspectFuncGetBySku   func(ctx context.Context, sku uint32)
	afterGetBySkuCounter  uint64
	beforeGetBySkuCounter uint64
	GetBySkuMock          mStockRepositoryMockGetBySku

	funcGetCountBySku          func(ctx context.Context, sku uint32) (u1 uint64, err error)
	inspectFuncGetCountBySku   func(ctx context.Context, sku uint32)
	afterGetCountBySkuCounter  uint64
	beforeGetCountBySkuCounter uint64
	GetCountBySkuMock          mStockRepositoryMockGetCountBySku

	funcReserve          func(ctx context.Context, items []model.Item) (err error)
	inspectFuncReserve   func(ctx context.Context, items []model.Item)
	afterReserveCounter  uint64
	beforeReserveCounter uint64
	ReserveMock          mStockRepositoryMockReserve

	funcUnReserve          func(ctx context.Context, items []model.Item) (err error)
	inspectFuncUnReserve   func(ctx context.Context, items []model.Item)
	afterUnReserveCounter  uint64
	beforeUnReserveCounter uint64
	UnReserveMock          mStockRepositoryMockUnReserve
}

// NewStockRepositoryMock returns a mock for order_usecase.StockRepository
func NewStockRepositoryMock(t minimock.Tester) *StockRepositoryMock {
	m := &StockRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetBySkuMock = mStockRepositoryMockGetBySku{mock: m}
	m.GetBySkuMock.callArgs = []*StockRepositoryMockGetBySkuParams{}

	m.GetCountBySkuMock = mStockRepositoryMockGetCountBySku{mock: m}
	m.GetCountBySkuMock.callArgs = []*StockRepositoryMockGetCountBySkuParams{}

	m.ReserveMock = mStockRepositoryMockReserve{mock: m}
	m.ReserveMock.callArgs = []*StockRepositoryMockReserveParams{}

	m.UnReserveMock = mStockRepositoryMockUnReserve{mock: m}
	m.UnReserveMock.callArgs = []*StockRepositoryMockUnReserveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStockRepositoryMockGetBySku struct {
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockGetBySkuExpectation
	expectations       []*StockRepositoryMockGetBySkuExpectation

	callArgs []*StockRepositoryMockGetBySkuParams
	mutex    sync.RWMutex
}

// StockRepositoryMockGetBySkuExpectation specifies expectation struct of the StockRepository.GetBySku
type StockRepositoryMockGetBySkuExpectation struct {
	mock    *StockRepositoryMock
	params  *StockRepositoryMockGetBySkuParams
	results *StockRepositoryMockGetBySkuResults
	Counter uint64
}

// StockRepositoryMockGetBySkuParams contains parameters of the StockRepository.GetBySku
type StockRepositoryMockGetBySkuParams struct {
	ctx context.Context
	sku uint32
}

// StockRepositoryMockGetBySkuResults contains results of the StockRepository.GetBySku
type StockRepositoryMockGetBySkuResults struct {
	p1  stock_repository.Product
	err error
}

// Expect sets up expected params for StockRepository.GetBySku
func (mmGetBySku *mStockRepositoryMockGetBySku) Expect(ctx context.Context, sku uint32) *mStockRepositoryMockGetBySku {
	if mmGetBySku.mock.funcGetBySku != nil {
		mmGetBySku.mock.t.Fatalf("StockRepositoryMock.GetBySku mock is already set by Set")
	}

	if mmGetBySku.defaultExpectation == nil {
		mmGetBySku.defaultExpectation = &StockRepositoryMockGetBySkuExpectation{}
	}

	mmGetBySku.defaultExpectation.params = &StockRepositoryMockGetBySkuParams{ctx, sku}
	for _, e := range mmGetBySku.expectations {
		if minimock.Equal(e.params, mmGetBySku.defaultExpectation.params) {
			mmGetBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBySku.defaultExpectation.params)
		}
	}

	return mmGetBySku
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.GetBySku
func (mmGetBySku *mStockRepositoryMockGetBySku) Inspect(f func(ctx context.Context, sku uint32)) *mStockRepositoryMockGetBySku {
	if mmGetBySku.mock.inspectFuncGetBySku != nil {
		mmGetBySku.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.GetBySku")
	}

	mmGetBySku.mock.inspectFuncGetBySku = f

	return mmGetBySku
}

// Return sets up results that will be returned by StockRepository.GetBySku
func (mmGetBySku *mStockRepositoryMockGetBySku) Return(p1 stock_repository.Product, err error) *StockRepositoryMock {
	if mmGetBySku.mock.funcGetBySku != nil {
		mmGetBySku.mock.t.Fatalf("StockRepositoryMock.GetBySku mock is already set by Set")
	}

	if mmGetBySku.defaultExpectation == nil {
		mmGetBySku.defaultExpectation = &StockRepositoryMockGetBySkuExpectation{mock: mmGetBySku.mock}
	}
	mmGetBySku.defaultExpectation.results = &StockRepositoryMockGetBySkuResults{p1, err}
	return mmGetBySku.mock
}

// Set uses given function f to mock the StockRepository.GetBySku method
func (mmGetBySku *mStockRepositoryMockGetBySku) Set(f func(ctx context.Context, sku uint32) (p1 stock_repository.Product, err error)) *StockRepositoryMock {
	if mmGetBySku.defaultExpectation != nil {
		mmGetBySku.mock.t.Fatalf("Default expectation is already set for the StockRepository.GetBySku method")
	}

	if len(mmGetBySku.expectations) > 0 {
		mmGetBySku.mock.t.Fatalf("Some expectations are already set for the StockRepository.GetBySku method")
	}

	mmGetBySku.mock.funcGetBySku = f
	return mmGetBySku.mock
}

// When sets expectation for the StockRepository.GetBySku which will trigger the result defined by the following
// Then helper
func (mmGetBySku *mStockRepositoryMockGetBySku) When(ctx context.Context, sku uint32) *StockRepositoryMockGetBySkuExpectation {
	if mmGetBySku.mock.funcGetBySku != nil {
		mmGetBySku.mock.t.Fatalf("StockRepositoryMock.GetBySku mock is already set by Set")
	}

	expectation := &StockRepositoryMockGetBySkuExpectation{
		mock:   mmGetBySku.mock,
		params: &StockRepositoryMockGetBySkuParams{ctx, sku},
	}
	mmGetBySku.expectations = append(mmGetBySku.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.GetBySku return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockGetBySkuExpectation) Then(p1 stock_repository.Product, err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockGetBySkuResults{p1, err}
	return e.mock
}

// GetBySku implements order_usecase.StockRepository
func (mmGetBySku *StockRepositoryMock) GetBySku(ctx context.Context, sku uint32) (p1 stock_repository.Product, err error) {
	mm_atomic.AddUint64(&mmGetBySku.beforeGetBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBySku.afterGetBySkuCounter, 1)

	if mmGetBySku.inspectFuncGetBySku != nil {
		mmGetBySku.inspectFuncGetBySku(ctx, sku)
	}

	mm_params := StockRepositoryMockGetBySkuParams{ctx, sku}

	// Record call args
	mmGetBySku.GetBySkuMock.mutex.Lock()
	mmGetBySku.GetBySkuMock.callArgs = append(mmGetBySku.GetBySkuMock.callArgs, &mm_params)
	mmGetBySku.GetBySkuMock.mutex.Unlock()

	for _, e := range mmGetBySku.GetBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetBySku.GetBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBySku.GetBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBySku.GetBySkuMock.defaultExpectation.params
		mm_got := StockRepositoryMockGetBySkuParams{ctx, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBySku.t.Errorf("StockRepositoryMock.GetBySku got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBySku.GetBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBySku.t.Fatal("No results are set for the StockRepositoryMock.GetBySku")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetBySku.funcGetBySku != nil {
		return mmGetBySku.funcGetBySku(ctx, sku)
	}
	mmGetBySku.t.Fatalf("Unexpected call to StockRepositoryMock.GetBySku. %v %v", ctx, sku)
	return
}

// GetBySkuAfterCounter returns a count of finished StockRepositoryMock.GetBySku invocations
func (mmGetBySku *StockRepositoryMock) GetBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySku.afterGetBySkuCounter)
}

// GetBySkuBeforeCounter returns a count of StockRepositoryMock.GetBySku invocations
func (mmGetBySku *StockRepositoryMock) GetBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySku.beforeGetBySkuCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.GetBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBySku *mStockRepositoryMockGetBySku) Calls() []*StockRepositoryMockGetBySkuParams {
	mmGetBySku.mutex.RLock()

	argCopy := make([]*StockRepositoryMockGetBySkuParams, len(mmGetBySku.callArgs))
	copy(argCopy, mmGetBySku.callArgs)

	mmGetBySku.mutex.RUnlock()

	return argCopy
}

// MinimockGetBySkuDone returns true if the count of the GetBySku invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockGetBySkuDone() bool {
	for _, e := range m.GetBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBySkuMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBySkuCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBySku != nil && mm_atomic.LoadUint64(&m.afterGetBySkuCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetBySkuInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockGetBySkuInspect() {
	for _, e := range m.GetBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.GetBySku with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBySkuMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBySkuCounter) < 1 {
		if m.GetBySkuMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockRepositoryMock.GetBySku")
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.GetBySku with params: %#v", *m.GetBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBySku != nil && mm_atomic.LoadUint64(&m.afterGetBySkuCounter) < 1 {
		m.t.Error("Expected call to StockRepositoryMock.GetBySku")
	}
}

type mStockRepositoryMockGetCountBySku struct {
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockGetCountBySkuExpectation
	expectations       []*StockRepositoryMockGetCountBySkuExpectation

	callArgs []*StockRepositoryMockGetCountBySkuParams
	mutex    sync.RWMutex
}

// StockRepositoryMockGetCountBySkuExpectation specifies expectation struct of the StockRepository.GetCountBySku
type StockRepositoryMockGetCountBySkuExpectation struct {
	mock    *StockRepositoryMock
	params  *StockRepositoryMockGetCountBySkuParams
	results *StockRepositoryMockGetCountBySkuResults
	Counter uint64
}

// StockRepositoryMockGetCountBySkuParams contains parameters of the StockRepository.GetCountBySku
type StockRepositoryMockGetCountBySkuParams struct {
	ctx context.Context
	sku uint32
}

// StockRepositoryMockGetCountBySkuResults contains results of the StockRepository.GetCountBySku
type StockRepositoryMockGetCountBySkuResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for StockRepository.GetCountBySku
func (mmGetCountBySku *mStockRepositoryMockGetCountBySku) Expect(ctx context.Context, sku uint32) *mStockRepositoryMockGetCountBySku {
	if mmGetCountBySku.mock.funcGetCountBySku != nil {
		mmGetCountBySku.mock.t.Fatalf("StockRepositoryMock.GetCountBySku mock is already set by Set")
	}

	if mmGetCountBySku.defaultExpectation == nil {
		mmGetCountBySku.defaultExpectation = &StockRepositoryMockGetCountBySkuExpectation{}
	}

	mmGetCountBySku.defaultExpectation.params = &StockRepositoryMockGetCountBySkuParams{ctx, sku}
	for _, e := range mmGetCountBySku.expectations {
		if minimock.Equal(e.params, mmGetCountBySku.defaultExpectation.params) {
			mmGetCountBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCountBySku.defaultExpectation.params)
		}
	}

	return mmGetCountBySku
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.GetCountBySku
func (mmGetCountBySku *mStockRepositoryMockGetCountBySku) Inspect(f func(ctx context.Context, sku uint32)) *mStockRepositoryMockGetCountBySku {
	if mmGetCountBySku.mock.inspectFuncGetCountBySku != nil {
		mmGetCountBySku.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.GetCountBySku")
	}

	mmGetCountBySku.mock.inspectFuncGetCountBySku = f

	return mmGetCountBySku
}

// Return sets up results that will be returned by StockRepository.GetCountBySku
func (mmGetCountBySku *mStockRepositoryMockGetCountBySku) Return(u1 uint64, err error) *StockRepositoryMock {
	if mmGetCountBySku.mock.funcGetCountBySku != nil {
		mmGetCountBySku.mock.t.Fatalf("StockRepositoryMock.GetCountBySku mock is already set by Set")
	}

	if mmGetCountBySku.defaultExpectation == nil {
		mmGetCountBySku.defaultExpectation = &StockRepositoryMockGetCountBySkuExpectation{mock: mmGetCountBySku.mock}
	}
	mmGetCountBySku.defaultExpectation.results = &StockRepositoryMockGetCountBySkuResults{u1, err}
	return mmGetCountBySku.mock
}

// Set uses given function f to mock the StockRepository.GetCountBySku method
func (mmGetCountBySku *mStockRepositoryMockGetCountBySku) Set(f func(ctx context.Context, sku uint32) (u1 uint64, err error)) *StockRepositoryMock {
	if mmGetCountBySku.defaultExpectation != nil {
		mmGetCountBySku.mock.t.Fatalf("Default expectation is already set for the StockRepository.GetCountBySku method")
	}

	if len(mmGetCountBySku.expectations) > 0 {
		mmGetCountBySku.mock.t.Fatalf("Some expectations are already set for the StockRepository.GetCountBySku method")
	}

	mmGetCountBySku.mock.funcGetCountBySku = f
	return mmGetCountBySku.mock
}

// When sets expectation for the StockRepository.GetCountBySku which will trigger the result defined by the following
// Then helper
func (mmGetCountBySku *mStockRepositoryMockGetCountBySku) When(ctx context.Context, sku uint32) *StockRepositoryMockGetCountBySkuExpectation {
	if mmGetCountBySku.mock.funcGetCountBySku != nil {
		mmGetCountBySku.mock.t.Fatalf("StockRepositoryMock.GetCountBySku mock is already set by Set")
	}

	expectation := &StockRepositoryMockGetCountBySkuExpectation{
		mock:   mmGetCountBySku.mock,
		params: &StockRepositoryMockGetCountBySkuParams{ctx, sku},
	}
	mmGetCountBySku.expectations = append(mmGetCountBySku.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.GetCountBySku return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockGetCountBySkuExpectation) Then(u1 uint64, err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockGetCountBySkuResults{u1, err}
	return e.mock
}

// GetCountBySku implements order_usecase.StockRepository
func (mmGetCountBySku *StockRepositoryMock) GetCountBySku(ctx context.Context, sku uint32) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetCountBySku.beforeGetCountBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCountBySku.afterGetCountBySkuCounter, 1)

	if mmGetCountBySku.inspectFuncGetCountBySku != nil {
		mmGetCountBySku.inspectFuncGetCountBySku(ctx, sku)
	}

	mm_params := StockRepositoryMockGetCountBySkuParams{ctx, sku}

	// Record call args
	mmGetCountBySku.GetCountBySkuMock.mutex.Lock()
	mmGetCountBySku.GetCountBySkuMock.callArgs = append(mmGetCountBySku.GetCountBySkuMock.callArgs, &mm_params)
	mmGetCountBySku.GetCountBySkuMock.mutex.Unlock()

	for _, e := range mmGetCountBySku.GetCountBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetCountBySku.GetCountBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCountBySku.GetCountBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCountBySku.GetCountBySkuMock.defaultExpectation.params
		mm_got := StockRepositoryMockGetCountBySkuParams{ctx, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCountBySku.t.Errorf("StockRepositoryMock.GetCountBySku got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCountBySku.GetCountBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCountBySku.t.Fatal("No results are set for the StockRepositoryMock.GetCountBySku")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetCountBySku.funcGetCountBySku != nil {
		return mmGetCountBySku.funcGetCountBySku(ctx, sku)
	}
	mmGetCountBySku.t.Fatalf("Unexpected call to StockRepositoryMock.GetCountBySku. %v %v", ctx, sku)
	return
}

// GetCountBySkuAfterCounter returns a count of finished StockRepositoryMock.GetCountBySku invocations
func (mmGetCountBySku *StockRepositoryMock) GetCountBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCountBySku.afterGetCountBySkuCounter)
}

// GetCountBySkuBeforeCounter returns a count of StockRepositoryMock.GetCountBySku invocations
func (mmGetCountBySku *StockRepositoryMock) GetCountBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCountBySku.beforeGetCountBySkuCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.GetCountBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCountBySku *mStockRepositoryMockGetCountBySku) Calls() []*StockRepositoryMockGetCountBySkuParams {
	mmGetCountBySku.mutex.RLock()

	argCopy := make([]*StockRepositoryMockGetCountBySkuParams, len(mmGetCountBySku.callArgs))
	copy(argCopy, mmGetCountBySku.callArgs)

	mmGetCountBySku.mutex.RUnlock()

	return argCopy
}

// MinimockGetCountBySkuDone returns true if the count of the GetCountBySku invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockGetCountBySkuDone() bool {
	for _, e := range m.GetCountBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCountBySkuMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCountBySkuCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCountBySku != nil && mm_atomic.LoadUint64(&m.afterGetCountBySkuCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCountBySkuInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockGetCountBySkuInspect() {
	for _, e := range m.GetCountBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.GetCountBySku with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCountBySkuMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCountBySkuCounter) < 1 {
		if m.GetCountBySkuMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockRepositoryMock.GetCountBySku")
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.GetCountBySku with params: %#v", *m.GetCountBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCountBySku != nil && mm_atomic.LoadUint64(&m.afterGetCountBySkuCounter) < 1 {
		m.t.Error("Expected call to StockRepositoryMock.GetCountBySku")
	}
}

type mStockRepositoryMockReserve struct {
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockReserveExpectation
	expectations       []*StockRepositoryMockReserveExpectation

	callArgs []*StockRepositoryMockReserveParams
	mutex    sync.RWMutex
}

// StockRepositoryMockReserveExpectation specifies expectation struct of the StockRepository.Reserve
type StockRepositoryMockReserveExpectation struct {
	mock    *StockRepositoryMock
	params  *StockRepositoryMockReserveParams
	results *StockRepositoryMockReserveResults
	Counter uint64
}

// StockRepositoryMockReserveParams contains parameters of the StockRepository.Reserve
type StockRepositoryMockReserveParams struct {
	ctx   context.Context
	items []model.Item
}

// StockRepositoryMockReserveResults contains results of the StockRepository.Reserve
type StockRepositoryMockReserveResults struct {
	err error
}

// Expect sets up expected params for StockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Expect(ctx context.Context, items []model.Item) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	mmReserve.defaultExpectation.params = &StockRepositoryMockReserveParams{ctx, items}
	for _, e := range mmReserve.expectations {
		if minimock.Equal(e.params, mmReserve.defaultExpectation.params) {
			mmReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserve.defaultExpectation.params)
		}
	}

	return mmReserve
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Inspect(f func(ctx context.Context, items []model.Item)) *mStockRepositoryMockReserve {
	if mmReserve.mock.inspectFuncReserve != nil {
		mmReserve.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.Reserve")
	}

	mmReserve.mock.inspectFuncReserve = f

	return mmReserve
}

// Return sets up results that will be returned by StockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Return(err error) *StockRepositoryMock {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{mock: mmReserve.mock}
	}
	mmReserve.defaultExpectation.results = &StockRepositoryMockReserveResults{err}
	return mmReserve.mock
}

// Set uses given function f to mock the StockRepository.Reserve method
func (mmReserve *mStockRepositoryMockReserve) Set(f func(ctx context.Context, items []model.Item) (err error)) *StockRepositoryMock {
	if mmReserve.defaultExpectation != nil {
		mmReserve.mock.t.Fatalf("Default expectation is already set for the StockRepository.Reserve method")
	}

	if len(mmReserve.expectations) > 0 {
		mmReserve.mock.t.Fatalf("Some expectations are already set for the StockRepository.Reserve method")
	}

	mmReserve.mock.funcReserve = f
	return mmReserve.mock
}

// When sets expectation for the StockRepository.Reserve which will trigger the result defined by the following
// Then helper
func (mmReserve *mStockRepositoryMockReserve) When(ctx context.Context, items []model.Item) *StockRepositoryMockReserveExpectation {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	expectation := &StockRepositoryMockReserveExpectation{
		mock:   mmReserve.mock,
		params: &StockRepositoryMockReserveParams{ctx, items},
	}
	mmReserve.expectations = append(mmReserve.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.Reserve return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockReserveExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockReserveResults{err}
	return e.mock
}

// Reserve implements order_usecase.StockRepository
func (mmReserve *StockRepositoryMock) Reserve(ctx context.Context, items []model.Item) (err error) {
	mm_atomic.AddUint64(&mmReserve.beforeReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserve.afterReserveCounter, 1)

	if mmReserve.inspectFuncReserve != nil {
		mmReserve.inspectFuncReserve(ctx, items)
	}

	mm_params := StockRepositoryMockReserveParams{ctx, items}

	// Record call args
	mmReserve.ReserveMock.mutex.Lock()
	mmReserve.ReserveMock.callArgs = append(mmReserve.ReserveMock.callArgs, &mm_params)
	mmReserve.ReserveMock.mutex.Unlock()

	for _, e := range mmReserve.ReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserve.ReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserve.ReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserve.ReserveMock.defaultExpectation.params
		mm_got := StockRepositoryMockReserveParams{ctx, items}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserve.ReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserve.t.Fatal("No results are set for the StockRepositoryMock.Reserve")
		}
		return (*mm_results).err
	}
	if mmReserve.funcReserve != nil {
		return mmReserve.funcReserve(ctx, items)
	}
	mmReserve.t.Fatalf("Unexpected call to StockRepositoryMock.Reserve. %v %v", ctx, items)
	return
}

// ReserveAfterCounter returns a count of finished StockRepositoryMock.Reserve invocations
func (mmReserve *StockRepositoryMock) ReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.afterReserveCounter)
}

// ReserveBeforeCounter returns a count of StockRepositoryMock.Reserve invocations
func (mmReserve *StockRepositoryMock) ReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.beforeReserveCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.Reserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserve *mStockRepositoryMockReserve) Calls() []*StockRepositoryMockReserveParams {
	mmReserve.mutex.RLock()

	argCopy := make([]*StockRepositoryMockReserveParams, len(mmReserve.callArgs))
	copy(argCopy, mmReserve.callArgs)

	mmReserve.mutex.RUnlock()

	return argCopy
}

// MinimockReserveDone returns true if the count of the Reserve invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockReserveDone() bool {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReserveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && mm_atomic.LoadUint64(&m.afterReserveCounter) < 1 {
		return false
	}
	return true
}

// MinimockReserveInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockReserveInspect() {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.Reserve with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReserveCounter) < 1 {
		if m.ReserveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockRepositoryMock.Reserve")
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.Reserve with params: %#v", *m.ReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && mm_atomic.LoadUint64(&m.afterReserveCounter) < 1 {
		m.t.Error("Expected call to StockRepositoryMock.Reserve")
	}
}

type mStockRepositoryMockUnReserve struct {
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockUnReserveExpectation
	expectations       []*StockRepositoryMockUnReserveExpectation

	callArgs []*StockRepositoryMockUnReserveParams
	mutex    sync.RWMutex
}

// StockRepositoryMockUnReserveExpectation specifies expectation struct of the StockRepository.UnReserve
type StockRepositoryMockUnReserveExpectation struct {
	mock    *StockRepositoryMock
	params  *StockRepositoryMockUnReserveParams
	results *StockRepositoryMockUnReserveResults
	Counter uint64
}

// StockRepositoryMockUnReserveParams contains parameters of the StockRepository.UnReserve
type StockRepositoryMockUnReserveParams struct {
	ctx   context.Context
	items []model.Item
}

// StockRepositoryMockUnReserveResults contains results of the StockRepository.UnReserve
type StockRepositoryMockUnReserveResults struct {
	err error
}

// Expect sets up expected params for StockRepository.UnReserve
func (mmUnReserve *mStockRepositoryMockUnReserve) Expect(ctx context.Context, items []model.Item) *mStockRepositoryMockUnReserve {
	if mmUnReserve.mock.funcUnReserve != nil {
		mmUnReserve.mock.t.Fatalf("StockRepositoryMock.UnReserve mock is already set by Set")
	}

	if mmUnReserve.defaultExpectation == nil {
		mmUnReserve.defaultExpectation = &StockRepositoryMockUnReserveExpectation{}
	}

	mmUnReserve.defaultExpectation.params = &StockRepositoryMockUnReserveParams{ctx, items}
	for _, e := range mmUnReserve.expectations {
		if minimock.Equal(e.params, mmUnReserve.defaultExpectation.params) {
			mmUnReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnReserve.defaultExpectation.params)
		}
	}

	return mmUnReserve
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.UnReserve
func (mmUnReserve *mStockRepositoryMockUnReserve) Inspect(f func(ctx context.Context, items []model.Item)) *mStockRepositoryMockUnReserve {
	if mmUnReserve.mock.inspectFuncUnReserve != nil {
		mmUnReserve.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.UnReserve")
	}

	mmUnReserve.mock.inspectFuncUnReserve = f

	return mmUnReserve
}

// Return sets up results that will be returned by StockRepository.UnReserve
func (mmUnReserve *mStockRepositoryMockUnReserve) Return(err error) *StockRepositoryMock {
	if mmUnReserve.mock.funcUnReserve != nil {
		mmUnReserve.mock.t.Fatalf("StockRepositoryMock.UnReserve mock is already set by Set")
	}

	if mmUnReserve.defaultExpectation == nil {
		mmUnReserve.defaultExpectation = &StockRepositoryMockUnReserveExpectation{mock: mmUnReserve.mock}
	}
	mmUnReserve.defaultExpectation.results = &StockRepositoryMockUnReserveResults{err}
	return mmUnReserve.mock
}

// Set uses given function f to mock the StockRepository.UnReserve method
func (mmUnReserve *mStockRepositoryMockUnReserve) Set(f func(ctx context.Context, items []model.Item) (err error)) *StockRepositoryMock {
	if mmUnReserve.defaultExpectation != nil {
		mmUnReserve.mock.t.Fatalf("Default expectation is already set for the StockRepository.UnReserve method")
	}

	if len(mmUnReserve.expectations) > 0 {
		mmUnReserve.mock.t.Fatalf("Some expectations are already set for the StockRepository.UnReserve method")
	}

	mmUnReserve.mock.funcUnReserve = f
	return mmUnReserve.mock
}

// When sets expectation for the StockRepository.UnReserve which will trigger the result defined by the following
// Then helper
func (mmUnReserve *mStockRepositoryMockUnReserve) When(ctx context.Context, items []model.Item) *StockRepositoryMockUnReserveExpectation {
	if mmUnReserve.mock.funcUnReserve != nil {
		mmUnReserve.mock.t.Fatalf("StockRepositoryMock.UnReserve mock is already set by Set")
	}

	expectation := &StockRepositoryMockUnReserveExpectation{
		mock:   mmUnReserve.mock,
		params: &StockRepositoryMockUnReserveParams{ctx, items},
	}
	mmUnReserve.expectations = append(mmUnReserve.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.UnReserve return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockUnReserveExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockUnReserveResults{err}
	return e.mock
}

// UnReserve implements order_usecase.StockRepository
func (mmUnReserve *StockRepositoryMock) UnReserve(ctx context.Context, items []model.Item) (err error) {
	mm_atomic.AddUint64(&mmUnReserve.beforeUnReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmUnReserve.afterUnReserveCounter, 1)

	if mmUnReserve.inspectFuncUnReserve != nil {
		mmUnReserve.inspectFuncUnReserve(ctx, items)
	}

	mm_params := StockRepositoryMockUnReserveParams{ctx, items}

	// Record call args
	mmUnReserve.UnReserveMock.mutex.Lock()
	mmUnReserve.UnReserveMock.callArgs = append(mmUnReserve.UnReserveMock.callArgs, &mm_params)
	mmUnReserve.UnReserveMock.mutex.Unlock()

	for _, e := range mmUnReserve.UnReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUnReserve.UnReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnReserve.UnReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmUnReserve.UnReserveMock.defaultExpectation.params
		mm_got := StockRepositoryMockUnReserveParams{ctx, items}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnReserve.t.Errorf("StockRepositoryMock.UnReserve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnReserve.UnReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmUnReserve.t.Fatal("No results are set for the StockRepositoryMock.UnReserve")
		}
		return (*mm_results).err
	}
	if mmUnReserve.funcUnReserve != nil {
		return mmUnReserve.funcUnReserve(ctx, items)
	}
	mmUnReserve.t.Fatalf("Unexpected call to StockRepositoryMock.UnReserve. %v %v", ctx, items)
	return
}

// UnReserveAfterCounter returns a count of finished StockRepositoryMock.UnReserve invocations
func (mmUnReserve *StockRepositoryMock) UnReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnReserve.afterUnReserveCounter)
}

// UnReserveBeforeCounter returns a count of StockRepositoryMock.UnReserve invocations
func (mmUnReserve *StockRepositoryMock) UnReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnReserve.beforeUnReserveCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.UnReserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnReserve *mStockRepositoryMockUnReserve) Calls() []*StockRepositoryMockUnReserveParams {
	mmUnReserve.mutex.RLock()

	argCopy := make([]*StockRepositoryMockUnReserveParams, len(mmUnReserve.callArgs))
	copy(argCopy, mmUnReserve.callArgs)

	mmUnReserve.mutex.RUnlock()

	return argCopy
}

// MinimockUnReserveDone returns true if the count of the UnReserve invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockUnReserveDone() bool {
	for _, e := range m.UnReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnReserveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnReserveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnReserve != nil && mm_atomic.LoadUint64(&m.afterUnReserveCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnReserveInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockUnReserveInspect() {
	for _, e := range m.UnReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.UnReserve with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnReserveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnReserveCounter) < 1 {
		if m.UnReserveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockRepositoryMock.UnReserve")
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.UnReserve with params: %#v", *m.UnReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnReserve != nil && mm_atomic.LoadUint64(&m.afterUnReserveCounter) < 1 {
		m.t.Error("Expected call to StockRepositoryMock.UnReserve")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetBySkuInspect()

			m.MinimockGetCountBySkuInspect()

			m.MinimockReserveInspect()

			m.MinimockUnReserveInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetBySkuDone() &&
		m.MinimockGetCountBySkuDone() &&
		m.MinimockReserveDone() &&
		m.MinimockUnReserveDone()
}
